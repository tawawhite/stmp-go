// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: examples/gomoku/gomoku_pb/gomoku.proto

package pb

import (
	fmt "fmt"
	_ "github.com/acrazing/stmp-go/stmp"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PlayerModel_Status int32

const (
	PlayerModel_Reserved PlayerModel_Status = 0
	PlayerModel_Free     PlayerModel_Status = 1
	PlayerModel_Standby  PlayerModel_Status = 2
	PlayerModel_Unready  PlayerModel_Status = 3
	PlayerModel_Ready    PlayerModel_Status = 4
	PlayerModel_Playing  PlayerModel_Status = 5
)

var PlayerModel_Status_name = map[int32]string{
	0: "Reserved",
	1: "Free",
	2: "Standby",
	3: "Unready",
	4: "Ready",
	5: "Playing",
}

var PlayerModel_Status_value = map[string]int32{
	"Reserved": 0,
	"Free":     1,
	"Standby":  2,
	"Unready":  3,
	"Ready":    4,
	"Playing":  5,
}

func (x PlayerModel_Status) String() string {
	return proto.EnumName(PlayerModel_Status_name, int32(x))
}

func (PlayerModel_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{1, 0}
}

type RoomModel_Reasons int32

const (
	RoomModel_Reserved      RoomModel_Reasons = 0
	RoomModel_InRoomAlready RoomModel_Reasons = 1
)

var RoomModel_Reasons_name = map[int32]string{
	0: "Reserved",
	1: "InRoomAlready",
}

var RoomModel_Reasons_value = map[string]int32{
	"Reserved":      0,
	"InRoomAlready": 1,
}

func (x RoomModel_Reasons) String() string {
	return proto.EnumName(RoomModel_Reasons_name, int32(x))
}

func (RoomModel_Reasons) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{2, 0}
}

type ApplyModel_Kind int32

const (
	ApplyModel_Reserved ApplyModel_Kind = 0
	ApplyModel_GiveUp   ApplyModel_Kind = 1
	ApplyModel_Draw     ApplyModel_Kind = 2
)

var ApplyModel_Kind_name = map[int32]string{
	0: "Reserved",
	1: "GiveUp",
	2: "Draw",
}

var ApplyModel_Kind_value = map[string]int32{
	"Reserved": 0,
	"GiveUp":   1,
	"Draw":     2,
}

func (x ApplyModel_Kind) String() string {
	return proto.EnumName(ApplyModel_Kind_name, int32(x))
}

func (ApplyModel_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{4, 0}
}

type GomokuModel_Result int32

const (
	GomokuModel_Playing          GomokuModel_Result = 0
	GomokuModel_Win              GomokuModel_Result = 1
	GomokuModel_Draw             GomokuModel_Result = 2
	GomokuModel_ApplyGiveUp      GomokuModel_Result = 3
	GomokuModel_ApplyDraw        GomokuModel_Result = 4
	GomokuModel_UserStepTimeout  GomokuModel_Result = 5
	GomokuModel_UserTotalTimeout GomokuModel_Result = 6
)

var GomokuModel_Result_name = map[int32]string{
	0: "Playing",
	1: "Win",
	2: "Draw",
	3: "ApplyGiveUp",
	4: "ApplyDraw",
	5: "UserStepTimeout",
	6: "UserTotalTimeout",
}

var GomokuModel_Result_value = map[string]int32{
	"Playing":          0,
	"Win":              1,
	"Draw":             2,
	"ApplyGiveUp":      3,
	"ApplyDraw":        4,
	"UserStepTimeout":  5,
	"UserTotalTimeout": 6,
}

func (x GomokuModel_Result) String() string {
	return proto.EnumName(GomokuModel_Result_name, int32(x))
}

func (GomokuModel_Result) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{5, 0}
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type PlayerModel struct {
	Id                   int64              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Status               PlayerModel_Status `protobuf:"varint,3,opt,name=status,proto3,enum=stmp.examples.gomoku.PlayerModel_Status" json:"status,omitempty"`
	RoomId               int64              `protobuf:"varint,4,opt,name=roomId,proto3" json:"roomId,omitempty"`
	Seat                 int32              `protobuf:"varint,5,opt,name=seat,proto3" json:"seat,omitempty"`
	GameId               int64              `protobuf:"varint,6,opt,name=gameId,proto3" json:"gameId,omitempty"`
	ReadyTimeout         int64              `protobuf:"varint,7,opt,name=readyTimeout,proto3" json:"readyTimeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *PlayerModel) Reset()         { *m = PlayerModel{} }
func (m *PlayerModel) String() string { return proto.CompactTextString(m) }
func (*PlayerModel) ProtoMessage()    {}
func (*PlayerModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{1}
}
func (m *PlayerModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerModel.Merge(m, src)
}
func (m *PlayerModel) XXX_Size() int {
	return m.Size()
}
func (m *PlayerModel) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerModel.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerModel proto.InternalMessageInfo

func (m *PlayerModel) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PlayerModel) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PlayerModel) GetStatus() PlayerModel_Status {
	if m != nil {
		return m.Status
	}
	return PlayerModel_Reserved
}

func (m *PlayerModel) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *PlayerModel) GetSeat() int32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *PlayerModel) GetGameId() int64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *PlayerModel) GetReadyTimeout() int64 {
	if m != nil {
		return m.ReadyTimeout
	}
	return 0
}

type RoomModel struct {
	Id                   int64           `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Players              map[int32]int64 `protobuf:"bytes,2,rep,name=players,proto3" json:"players,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	GameId               int64           `protobuf:"varint,3,opt,name=gameId,proto3" json:"gameId,omitempty"`
	Spectators           []int64         `protobuf:"varint,4,rep,packed,name=spectators,proto3" json:"spectators,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RoomModel) Reset()         { *m = RoomModel{} }
func (m *RoomModel) String() string { return proto.CompactTextString(m) }
func (*RoomModel) ProtoMessage()    {}
func (*RoomModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{2}
}
func (m *RoomModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoomModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomModel.Merge(m, src)
}
func (m *RoomModel) XXX_Size() int {
	return m.Size()
}
func (m *RoomModel) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomModel.DiscardUnknown(m)
}

var xxx_messageInfo_RoomModel proto.InternalMessageInfo

func (m *RoomModel) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoomModel) GetPlayers() map[int32]int64 {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *RoomModel) GetGameId() int64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *RoomModel) GetSpectators() []int64 {
	if m != nil {
		return m.Spectators
	}
	return nil
}

type HandModel struct {
	X                    int32    `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	T                    int32    `protobuf:"varint,3,opt,name=t,proto3" json:"t,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HandModel) Reset()         { *m = HandModel{} }
func (m *HandModel) String() string { return proto.CompactTextString(m) }
func (*HandModel) ProtoMessage()    {}
func (*HandModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{3}
}
func (m *HandModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandModel.Merge(m, src)
}
func (m *HandModel) XXX_Size() int {
	return m.Size()
}
func (m *HandModel) XXX_DiscardUnknown() {
	xxx_messageInfo_HandModel.DiscardUnknown(m)
}

var xxx_messageInfo_HandModel proto.InternalMessageInfo

func (m *HandModel) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *HandModel) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *HandModel) GetT() int32 {
	if m != nil {
		return m.T
	}
	return 0
}

type ApplyModel struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApplyModel) Reset()         { *m = ApplyModel{} }
func (m *ApplyModel) String() string { return proto.CompactTextString(m) }
func (*ApplyModel) ProtoMessage()    {}
func (*ApplyModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{4}
}
func (m *ApplyModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyModel.Merge(m, src)
}
func (m *ApplyModel) XXX_Size() int {
	return m.Size()
}
func (m *ApplyModel) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyModel.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyModel proto.InternalMessageInfo

type GomokuModel struct {
	Id                   int64              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	RoomId               int64              `protobuf:"varint,2,opt,name=roomId,proto3" json:"roomId,omitempty"`
	PlayerBlack          int64              `protobuf:"varint,3,opt,name=playerBlack,proto3" json:"playerBlack,omitempty"`
	PlayerWhite          int64              `protobuf:"varint,4,opt,name=playerWhite,proto3" json:"playerWhite,omitempty"`
	SeatBlack            int32              `protobuf:"varint,5,opt,name=seatBlack,proto3" json:"seatBlack,omitempty"`
	SeatWhite            int32              `protobuf:"varint,6,opt,name=seatWhite,proto3" json:"seatWhite,omitempty"`
	History              []*HandModel       `protobuf:"bytes,7,rep,name=history,proto3" json:"history,omitempty"`
	CreatedAt            int64              `protobuf:"varint,8,opt,name=createdAt,proto3" json:"createdAt,omitempty"`
	Result               GomokuModel_Result `protobuf:"varint,9,opt,name=result,proto3,enum=stmp.examples.gomoku.GomokuModel_Result" json:"result,omitempty"`
	Winner               int64              `protobuf:"varint,10,opt,name=winner,proto3" json:"winner,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GomokuModel) Reset()         { *m = GomokuModel{} }
func (m *GomokuModel) String() string { return proto.CompactTextString(m) }
func (*GomokuModel) ProtoMessage()    {}
func (*GomokuModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{5}
}
func (m *GomokuModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GomokuModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GomokuModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GomokuModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GomokuModel.Merge(m, src)
}
func (m *GomokuModel) XXX_Size() int {
	return m.Size()
}
func (m *GomokuModel) XXX_DiscardUnknown() {
	xxx_messageInfo_GomokuModel.DiscardUnknown(m)
}

var xxx_messageInfo_GomokuModel proto.InternalMessageInfo

func (m *GomokuModel) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GomokuModel) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *GomokuModel) GetPlayerBlack() int64 {
	if m != nil {
		return m.PlayerBlack
	}
	return 0
}

func (m *GomokuModel) GetPlayerWhite() int64 {
	if m != nil {
		return m.PlayerWhite
	}
	return 0
}

func (m *GomokuModel) GetSeatBlack() int32 {
	if m != nil {
		return m.SeatBlack
	}
	return 0
}

func (m *GomokuModel) GetSeatWhite() int32 {
	if m != nil {
		return m.SeatWhite
	}
	return 0
}

func (m *GomokuModel) GetHistory() []*HandModel {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *GomokuModel) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *GomokuModel) GetResult() GomokuModel_Result {
	if m != nil {
		return m.Result
	}
	return GomokuModel_Playing
}

func (m *GomokuModel) GetWinner() int64 {
	if m != nil {
		return m.Winner
	}
	return 0
}

type FullRoomModel struct {
	Room                 *RoomModel             `protobuf:"bytes,1,opt,name=room,proto3" json:"room,omitempty"`
	Players              map[int64]*PlayerModel `protobuf:"bytes,2,rep,name=players,proto3" json:"players,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Game                 *GomokuModel           `protobuf:"bytes,3,opt,name=game,proto3" json:"game,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *FullRoomModel) Reset()         { *m = FullRoomModel{} }
func (m *FullRoomModel) String() string { return proto.CompactTextString(m) }
func (*FullRoomModel) ProtoMessage()    {}
func (*FullRoomModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{6}
}
func (m *FullRoomModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FullRoomModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FullRoomModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FullRoomModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FullRoomModel.Merge(m, src)
}
func (m *FullRoomModel) XXX_Size() int {
	return m.Size()
}
func (m *FullRoomModel) XXX_DiscardUnknown() {
	xxx_messageInfo_FullRoomModel.DiscardUnknown(m)
}

var xxx_messageInfo_FullRoomModel proto.InternalMessageInfo

func (m *FullRoomModel) GetRoom() *RoomModel {
	if m != nil {
		return m.Room
	}
	return nil
}

func (m *FullRoomModel) GetPlayers() map[int64]*PlayerModel {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *FullRoomModel) GetGame() *GomokuModel {
	if m != nil {
		return m.Game
	}
	return nil
}

type ListInput struct {
	Limit                int64    `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset               int64    `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListInput) Reset()         { *m = ListInput{} }
func (m *ListInput) String() string { return proto.CompactTextString(m) }
func (*ListInput) ProtoMessage()    {}
func (*ListInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{7}
}
func (m *ListInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListInput.Merge(m, src)
}
func (m *ListInput) XXX_Size() int {
	return m.Size()
}
func (m *ListInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ListInput.DiscardUnknown(m)
}

var xxx_messageInfo_ListInput proto.InternalMessageInfo

func (m *ListInput) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListInput) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type ListRoomOutput struct {
	Total                int64        `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Rooms                []*RoomModel `protobuf:"bytes,2,rep,name=rooms,proto3" json:"rooms,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ListRoomOutput) Reset()         { *m = ListRoomOutput{} }
func (m *ListRoomOutput) String() string { return proto.CompactTextString(m) }
func (*ListRoomOutput) ProtoMessage()    {}
func (*ListRoomOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{8}
}
func (m *ListRoomOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRoomOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRoomOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRoomOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRoomOutput.Merge(m, src)
}
func (m *ListRoomOutput) XXX_Size() int {
	return m.Size()
}
func (m *ListRoomOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRoomOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ListRoomOutput proto.InternalMessageInfo

func (m *ListRoomOutput) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ListRoomOutput) GetRooms() []*RoomModel {
	if m != nil {
		return m.Rooms
	}
	return nil
}

type LookonRoomInput struct {
	RoomId               int64    `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LookonRoomInput) Reset()         { *m = LookonRoomInput{} }
func (m *LookonRoomInput) String() string { return proto.CompactTextString(m) }
func (*LookonRoomInput) ProtoMessage()    {}
func (*LookonRoomInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{9}
}
func (m *LookonRoomInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LookonRoomInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LookonRoomInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LookonRoomInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LookonRoomInput.Merge(m, src)
}
func (m *LookonRoomInput) XXX_Size() int {
	return m.Size()
}
func (m *LookonRoomInput) XXX_DiscardUnknown() {
	xxx_messageInfo_LookonRoomInput.DiscardUnknown(m)
}

var xxx_messageInfo_LookonRoomInput proto.InternalMessageInfo

func (m *LookonRoomInput) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type JoinRoomInput struct {
	RoomId               int64    `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	PreferSeat           int32    `protobuf:"varint,2,opt,name=preferSeat,proto3" json:"preferSeat,omitempty"`
	Seat                 int32    `protobuf:"varint,3,opt,name=seat,proto3" json:"seat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JoinRoomInput) Reset()         { *m = JoinRoomInput{} }
func (m *JoinRoomInput) String() string { return proto.CompactTextString(m) }
func (*JoinRoomInput) ProtoMessage()    {}
func (*JoinRoomInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{10}
}
func (m *JoinRoomInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinRoomInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JoinRoomInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JoinRoomInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinRoomInput.Merge(m, src)
}
func (m *JoinRoomInput) XXX_Size() int {
	return m.Size()
}
func (m *JoinRoomInput) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinRoomInput.DiscardUnknown(m)
}

var xxx_messageInfo_JoinRoomInput proto.InternalMessageInfo

func (m *JoinRoomInput) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *JoinRoomInput) GetPreferSeat() int32 {
	if m != nil {
		return m.PreferSeat
	}
	return 0
}

func (m *JoinRoomInput) GetSeat() int32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

type UserJoinEvent struct {
	UserId               int64    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Seat                 int32    `protobuf:"varint,2,opt,name=seat,proto3" json:"seat,omitempty"`
	ReadyTimeout         int32    `protobuf:"varint,3,opt,name=readyTimeout,proto3" json:"readyTimeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserJoinEvent) Reset()         { *m = UserJoinEvent{} }
func (m *UserJoinEvent) String() string { return proto.CompactTextString(m) }
func (*UserJoinEvent) ProtoMessage()    {}
func (*UserJoinEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{11}
}
func (m *UserJoinEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserJoinEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserJoinEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserJoinEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserJoinEvent.Merge(m, src)
}
func (m *UserJoinEvent) XXX_Size() int {
	return m.Size()
}
func (m *UserJoinEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UserJoinEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UserJoinEvent proto.InternalMessageInfo

func (m *UserJoinEvent) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserJoinEvent) GetSeat() int32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *UserJoinEvent) GetReadyTimeout() int32 {
	if m != nil {
		return m.ReadyTimeout
	}
	return 0
}

type UserReadyEvent struct {
	UserId               int64    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserReadyEvent) Reset()         { *m = UserReadyEvent{} }
func (m *UserReadyEvent) String() string { return proto.CompactTextString(m) }
func (*UserReadyEvent) ProtoMessage()    {}
func (*UserReadyEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{12}
}
func (m *UserReadyEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserReadyEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserReadyEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserReadyEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserReadyEvent.Merge(m, src)
}
func (m *UserReadyEvent) XXX_Size() int {
	return m.Size()
}
func (m *UserReadyEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UserReadyEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UserReadyEvent proto.InternalMessageInfo

func (m *UserReadyEvent) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type UserUnreadyEvent struct {
	UserId               int64    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ReadyTimeout         int32    `protobuf:"varint,2,opt,name=readyTimeout,proto3" json:"readyTimeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserUnreadyEvent) Reset()         { *m = UserUnreadyEvent{} }
func (m *UserUnreadyEvent) String() string { return proto.CompactTextString(m) }
func (*UserUnreadyEvent) ProtoMessage()    {}
func (*UserUnreadyEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{13}
}
func (m *UserUnreadyEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserUnreadyEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserUnreadyEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserUnreadyEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserUnreadyEvent.Merge(m, src)
}
func (m *UserUnreadyEvent) XXX_Size() int {
	return m.Size()
}
func (m *UserUnreadyEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UserUnreadyEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UserUnreadyEvent proto.InternalMessageInfo

func (m *UserUnreadyEvent) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserUnreadyEvent) GetReadyTimeout() int32 {
	if m != nil {
		return m.ReadyTimeout
	}
	return 0
}

type UserLookonEvent struct {
	UserId               int64    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserLookonEvent) Reset()         { *m = UserLookonEvent{} }
func (m *UserLookonEvent) String() string { return proto.CompactTextString(m) }
func (*UserLookonEvent) ProtoMessage()    {}
func (*UserLookonEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{14}
}
func (m *UserLookonEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserLookonEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserLookonEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserLookonEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserLookonEvent.Merge(m, src)
}
func (m *UserLookonEvent) XXX_Size() int {
	return m.Size()
}
func (m *UserLookonEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UserLookonEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UserLookonEvent proto.InternalMessageInfo

func (m *UserLookonEvent) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type UserExitEvent struct {
	UserId               int64    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserExitEvent) Reset()         { *m = UserExitEvent{} }
func (m *UserExitEvent) String() string { return proto.CompactTextString(m) }
func (*UserExitEvent) ProtoMessage()    {}
func (*UserExitEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{15}
}
func (m *UserExitEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserExitEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserExitEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserExitEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserExitEvent.Merge(m, src)
}
func (m *UserExitEvent) XXX_Size() int {
	return m.Size()
}
func (m *UserExitEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UserExitEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UserExitEvent proto.InternalMessageInfo

func (m *UserExitEvent) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type ApplyInput struct {
	Kind                 ApplyModel_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=stmp.examples.gomoku.ApplyModel_Kind" json:"kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ApplyInput) Reset()         { *m = ApplyInput{} }
func (m *ApplyInput) String() string { return proto.CompactTextString(m) }
func (*ApplyInput) ProtoMessage()    {}
func (*ApplyInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{16}
}
func (m *ApplyInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplyInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplyInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplyInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplyInput.Merge(m, src)
}
func (m *ApplyInput) XXX_Size() int {
	return m.Size()
}
func (m *ApplyInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplyInput.DiscardUnknown(m)
}

var xxx_messageInfo_ApplyInput proto.InternalMessageInfo

func (m *ApplyInput) GetKind() ApplyModel_Kind {
	if m != nil {
		return m.Kind
	}
	return ApplyModel_Reserved
}

type ReplyInput struct {
	Kind                 ApplyModel_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=stmp.examples.gomoku.ApplyModel_Kind" json:"kind,omitempty"`
	Accept               bool            `protobuf:"varint,2,opt,name=accept,proto3" json:"accept,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ReplyInput) Reset()         { *m = ReplyInput{} }
func (m *ReplyInput) String() string { return proto.CompactTextString(m) }
func (*ReplyInput) ProtoMessage()    {}
func (*ReplyInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{17}
}
func (m *ReplyInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplyInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplyInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplyInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplyInput.Merge(m, src)
}
func (m *ReplyInput) XXX_Size() int {
	return m.Size()
}
func (m *ReplyInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplyInput.DiscardUnknown(m)
}

var xxx_messageInfo_ReplyInput proto.InternalMessageInfo

func (m *ReplyInput) GetKind() ApplyModel_Kind {
	if m != nil {
		return m.Kind
	}
	return ApplyModel_Reserved
}

func (m *ReplyInput) GetAccept() bool {
	if m != nil {
		return m.Accept
	}
	return false
}

type UserPlayEvent struct {
	UserId               int64      `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Hand                 *HandModel `protobuf:"bytes,2,opt,name=hand,proto3" json:"hand,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *UserPlayEvent) Reset()         { *m = UserPlayEvent{} }
func (m *UserPlayEvent) String() string { return proto.CompactTextString(m) }
func (*UserPlayEvent) ProtoMessage()    {}
func (*UserPlayEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{18}
}
func (m *UserPlayEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPlayEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPlayEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPlayEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPlayEvent.Merge(m, src)
}
func (m *UserPlayEvent) XXX_Size() int {
	return m.Size()
}
func (m *UserPlayEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPlayEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UserPlayEvent proto.InternalMessageInfo

func (m *UserPlayEvent) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserPlayEvent) GetHand() *HandModel {
	if m != nil {
		return m.Hand
	}
	return nil
}

type UserApplyEvent struct {
	Kind                 ApplyModel_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=stmp.examples.gomoku.ApplyModel_Kind" json:"kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UserApplyEvent) Reset()         { *m = UserApplyEvent{} }
func (m *UserApplyEvent) String() string { return proto.CompactTextString(m) }
func (*UserApplyEvent) ProtoMessage()    {}
func (*UserApplyEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{19}
}
func (m *UserApplyEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApplyEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApplyEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApplyEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApplyEvent.Merge(m, src)
}
func (m *UserApplyEvent) XXX_Size() int {
	return m.Size()
}
func (m *UserApplyEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApplyEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UserApplyEvent proto.InternalMessageInfo

func (m *UserApplyEvent) GetKind() ApplyModel_Kind {
	if m != nil {
		return m.Kind
	}
	return ApplyModel_Reserved
}

type UserReplyEvent struct {
	Kind                 ApplyModel_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=stmp.examples.gomoku.ApplyModel_Kind" json:"kind,omitempty"`
	Accepted             bool            `protobuf:"varint,2,opt,name=accepted,proto3" json:"accepted,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UserReplyEvent) Reset()         { *m = UserReplyEvent{} }
func (m *UserReplyEvent) String() string { return proto.CompactTextString(m) }
func (*UserReplyEvent) ProtoMessage()    {}
func (*UserReplyEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{20}
}
func (m *UserReplyEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserReplyEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserReplyEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserReplyEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserReplyEvent.Merge(m, src)
}
func (m *UserReplyEvent) XXX_Size() int {
	return m.Size()
}
func (m *UserReplyEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UserReplyEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UserReplyEvent proto.InternalMessageInfo

func (m *UserReplyEvent) GetKind() ApplyModel_Kind {
	if m != nil {
		return m.Kind
	}
	return ApplyModel_Reserved
}

func (m *UserReplyEvent) GetAccepted() bool {
	if m != nil {
		return m.Accepted
	}
	return false
}

type UserDisconnectedEvent struct {
	UserId               int64    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	WaitTimeout          int32    `protobuf:"varint,2,opt,name=waitTimeout,proto3" json:"waitTimeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserDisconnectedEvent) Reset()         { *m = UserDisconnectedEvent{} }
func (m *UserDisconnectedEvent) String() string { return proto.CompactTextString(m) }
func (*UserDisconnectedEvent) ProtoMessage()    {}
func (*UserDisconnectedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{21}
}
func (m *UserDisconnectedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserDisconnectedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserDisconnectedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserDisconnectedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDisconnectedEvent.Merge(m, src)
}
func (m *UserDisconnectedEvent) XXX_Size() int {
	return m.Size()
}
func (m *UserDisconnectedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDisconnectedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UserDisconnectedEvent proto.InternalMessageInfo

func (m *UserDisconnectedEvent) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserDisconnectedEvent) GetWaitTimeout() int32 {
	if m != nil {
		return m.WaitTimeout
	}
	return 0
}

type UserConnectedEvent struct {
	UserId               int64    `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserConnectedEvent) Reset()         { *m = UserConnectedEvent{} }
func (m *UserConnectedEvent) String() string { return proto.CompactTextString(m) }
func (*UserConnectedEvent) ProtoMessage()    {}
func (*UserConnectedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{22}
}
func (m *UserConnectedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserConnectedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserConnectedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserConnectedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserConnectedEvent.Merge(m, src)
}
func (m *UserConnectedEvent) XXX_Size() int {
	return m.Size()
}
func (m *UserConnectedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UserConnectedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UserConnectedEvent proto.InternalMessageInfo

func (m *UserConnectedEvent) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type LoginInput struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoginInput) Reset()         { *m = LoginInput{} }
func (m *LoginInput) String() string { return proto.CompactTextString(m) }
func (*LoginInput) ProtoMessage()    {}
func (*LoginInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{23}
}
func (m *LoginInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginInput.Merge(m, src)
}
func (m *LoginInput) XXX_Size() int {
	return m.Size()
}
func (m *LoginInput) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginInput.DiscardUnknown(m)
}

var xxx_messageInfo_LoginInput proto.InternalMessageInfo

func (m *LoginInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ListPlayerInput struct {
	Limit                int64    `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset               int64    `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Ids                  []int64  `protobuf:"varint,3,rep,packed,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPlayerInput) Reset()         { *m = ListPlayerInput{} }
func (m *ListPlayerInput) String() string { return proto.CompactTextString(m) }
func (*ListPlayerInput) ProtoMessage()    {}
func (*ListPlayerInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{24}
}
func (m *ListPlayerInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListPlayerInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListPlayerInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListPlayerInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPlayerInput.Merge(m, src)
}
func (m *ListPlayerInput) XXX_Size() int {
	return m.Size()
}
func (m *ListPlayerInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPlayerInput.DiscardUnknown(m)
}

var xxx_messageInfo_ListPlayerInput proto.InternalMessageInfo

func (m *ListPlayerInput) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListPlayerInput) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ListPlayerInput) GetIds() []int64 {
	if m != nil {
		return m.Ids
	}
	return nil
}

type ListPlayerOutput struct {
	Total                int64          `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Players              []*PlayerModel `protobuf:"bytes,2,rep,name=players,proto3" json:"players,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListPlayerOutput) Reset()         { *m = ListPlayerOutput{} }
func (m *ListPlayerOutput) String() string { return proto.CompactTextString(m) }
func (*ListPlayerOutput) ProtoMessage()    {}
func (*ListPlayerOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e7af59a04f5563a, []int{25}
}
func (m *ListPlayerOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListPlayerOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListPlayerOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListPlayerOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPlayerOutput.Merge(m, src)
}
func (m *ListPlayerOutput) XXX_Size() int {
	return m.Size()
}
func (m *ListPlayerOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPlayerOutput.DiscardUnknown(m)
}

var xxx_messageInfo_ListPlayerOutput proto.InternalMessageInfo

func (m *ListPlayerOutput) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ListPlayerOutput) GetPlayers() []*PlayerModel {
	if m != nil {
		return m.Players
	}
	return nil
}

func init() {
	proto.RegisterEnum("stmp.examples.gomoku.PlayerModel_Status", PlayerModel_Status_name, PlayerModel_Status_value)
	proto.RegisterEnum("stmp.examples.gomoku.RoomModel_Reasons", RoomModel_Reasons_name, RoomModel_Reasons_value)
	proto.RegisterEnum("stmp.examples.gomoku.ApplyModel_Kind", ApplyModel_Kind_name, ApplyModel_Kind_value)
	proto.RegisterEnum("stmp.examples.gomoku.GomokuModel_Result", GomokuModel_Result_name, GomokuModel_Result_value)
	proto.RegisterType((*Empty)(nil), "stmp.examples.gomoku.Empty")
	proto.RegisterType((*PlayerModel)(nil), "stmp.examples.gomoku.PlayerModel")
	proto.RegisterType((*RoomModel)(nil), "stmp.examples.gomoku.RoomModel")
	proto.RegisterMapType((map[int32]int64)(nil), "stmp.examples.gomoku.RoomModel.PlayersEntry")
	proto.RegisterType((*HandModel)(nil), "stmp.examples.gomoku.HandModel")
	proto.RegisterType((*ApplyModel)(nil), "stmp.examples.gomoku.ApplyModel")
	proto.RegisterType((*GomokuModel)(nil), "stmp.examples.gomoku.GomokuModel")
	proto.RegisterType((*FullRoomModel)(nil), "stmp.examples.gomoku.FullRoomModel")
	proto.RegisterMapType((map[int64]*PlayerModel)(nil), "stmp.examples.gomoku.FullRoomModel.PlayersEntry")
	proto.RegisterType((*ListInput)(nil), "stmp.examples.gomoku.ListInput")
	proto.RegisterType((*ListRoomOutput)(nil), "stmp.examples.gomoku.ListRoomOutput")
	proto.RegisterType((*LookonRoomInput)(nil), "stmp.examples.gomoku.LookonRoomInput")
	proto.RegisterType((*JoinRoomInput)(nil), "stmp.examples.gomoku.JoinRoomInput")
	proto.RegisterType((*UserJoinEvent)(nil), "stmp.examples.gomoku.UserJoinEvent")
	proto.RegisterType((*UserReadyEvent)(nil), "stmp.examples.gomoku.UserReadyEvent")
	proto.RegisterType((*UserUnreadyEvent)(nil), "stmp.examples.gomoku.UserUnreadyEvent")
	proto.RegisterType((*UserLookonEvent)(nil), "stmp.examples.gomoku.UserLookonEvent")
	proto.RegisterType((*UserExitEvent)(nil), "stmp.examples.gomoku.UserExitEvent")
	proto.RegisterType((*ApplyInput)(nil), "stmp.examples.gomoku.ApplyInput")
	proto.RegisterType((*ReplyInput)(nil), "stmp.examples.gomoku.ReplyInput")
	proto.RegisterType((*UserPlayEvent)(nil), "stmp.examples.gomoku.UserPlayEvent")
	proto.RegisterType((*UserApplyEvent)(nil), "stmp.examples.gomoku.UserApplyEvent")
	proto.RegisterType((*UserReplyEvent)(nil), "stmp.examples.gomoku.UserReplyEvent")
	proto.RegisterType((*UserDisconnectedEvent)(nil), "stmp.examples.gomoku.UserDisconnectedEvent")
	proto.RegisterType((*UserConnectedEvent)(nil), "stmp.examples.gomoku.UserConnectedEvent")
	proto.RegisterType((*LoginInput)(nil), "stmp.examples.gomoku.LoginInput")
	proto.RegisterType((*ListPlayerInput)(nil), "stmp.examples.gomoku.ListPlayerInput")
	proto.RegisterType((*ListPlayerOutput)(nil), "stmp.examples.gomoku.ListPlayerOutput")
}

func init() {
	proto.RegisterFile("examples/gomoku/gomoku_pb/gomoku.proto", fileDescriptor_4e7af59a04f5563a)
}

var fileDescriptor_4e7af59a04f5563a = []byte{
	// 1612 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4b, 0x6f, 0xdb, 0xc6,
	0x16, 0x0e, 0x5f, 0x7a, 0x1c, 0x59, 0xb6, 0xee, 0xdc, 0xe4, 0x42, 0xd0, 0xbd, 0x70, 0x74, 0xd9,
	0x34, 0x55, 0xd2, 0x58, 0x2e, 0x14, 0x04, 0xcd, 0x63, 0x53, 0x27, 0xb1, 0x1d, 0xc7, 0x71, 0xd3,
	0x50, 0x71, 0xd3, 0x36, 0x0d, 0xdc, 0xb1, 0x38, 0x91, 0x09, 0x8b, 0x0f, 0x90, 0x23, 0xc5, 0xea,
	0xae, 0xc8, 0xa6, 0xcb, 0xfe, 0x8a, 0xa2, 0xbb, 0xee, 0xbb, 0xea, 0x32, 0x9b, 0x02, 0xf9, 0x03,
	0x05, 0x8a, 0x00, 0x5d, 0xf4, 0x5f, 0x14, 0x33, 0x43, 0x8a, 0x94, 0x22, 0x52, 0x4c, 0x93, 0x95,
	0x67, 0x86, 0xe7, 0x7c, 0x67, 0xe6, 0x3b, 0x4f, 0x0b, 0xce, 0x93, 0x13, 0x6c, 0x7b, 0x03, 0x12,
	0xac, 0xf7, 0x5d, 0xdb, 0x3d, 0x1e, 0x86, 0x7f, 0x0e, 0xbc, 0xc3, 0x70, 0xd5, 0xf6, 0x7c, 0x97,
	0xba, 0xe8, 0x74, 0x40, 0x6d, 0xaf, 0x1d, 0x09, 0xb7, 0xc5, 0xb7, 0xc6, 0x46, 0xdf, 0xa2, 0x47,
	0xc3, 0xc3, 0x76, 0xcf, 0xb5, 0xd7, 0x89, 0x33, 0x72, 0xc7, 0x9e, 0xef, 0x9e, 0x8c, 0xd7, 0xb9,
	0x4a, 0x6f, 0xad, 0x4f, 0x9c, 0xb5, 0x11, 0x1e, 0x58, 0x26, 0xa6, 0x64, 0xfd, 0xb5, 0x85, 0x00,
	0x6e, 0xac, 0x30, 0xe0, 0x75, 0x8e, 0xce, 0x0f, 0xf4, 0x22, 0x68, 0x9b, 0xb6, 0x47, 0xc7, 0xfa,
	0xcf, 0x32, 0x54, 0x3e, 0x1b, 0xe0, 0x31, 0xf1, 0xf7, 0x5c, 0x93, 0x0c, 0xd0, 0x32, 0xc8, 0x96,
	0x59, 0x97, 0x9a, 0x52, 0x4b, 0x31, 0x64, 0xcb, 0x44, 0x08, 0x54, 0x07, 0xdb, 0xa4, 0x2e, 0x37,
	0xa5, 0x56, 0xd9, 0xe0, 0x6b, 0xf4, 0x09, 0x14, 0x02, 0x8a, 0xe9, 0x30, 0xa8, 0x2b, 0x4d, 0xa9,
	0xb5, 0xdc, 0x69, 0xb5, 0xe7, 0xdd, 0xbb, 0x9d, 0x80, 0x6d, 0x77, 0xb9, 0xbc, 0x11, 0xea, 0xa1,
	0xff, 0x40, 0xc1, 0x77, 0x5d, 0x7b, 0xc7, 0xac, 0xab, 0xdc, 0x52, 0xb8, 0x63, 0xd6, 0x02, 0x82,
	0x69, 0x5d, 0x6b, 0x4a, 0x2d, 0xcd, 0xe0, 0x6b, 0x26, 0xdb, 0xc7, 0x36, 0xd9, 0x31, 0xeb, 0x05,
	0x21, 0x2b, 0x76, 0x48, 0x87, 0x25, 0x9f, 0x60, 0x73, 0xfc, 0xd0, 0xb2, 0x89, 0x3b, 0xa4, 0xf5,
	0x22, 0xff, 0x3a, 0x75, 0xa6, 0x1b, 0x50, 0x10, 0x96, 0xd1, 0x12, 0x94, 0x0c, 0x12, 0x10, 0x7f,
	0x44, 0xcc, 0xda, 0x29, 0x54, 0x02, 0x75, 0xcb, 0x27, 0xa4, 0x26, 0xa1, 0x0a, 0x14, 0xbb, 0x14,
	0x3b, 0xe6, 0xe1, 0xb8, 0x26, 0xb3, 0xcd, 0xbe, 0xc3, 0x01, 0x6a, 0x0a, 0x2a, 0x83, 0x66, 0xf0,
	0xa5, 0xca, 0xce, 0xd9, 0x63, 0x2c, 0xa7, 0x5f, 0xd3, 0xf4, 0xe7, 0x32, 0x94, 0x0d, 0xd7, 0xb5,
	0xe7, 0xf3, 0xb5, 0x05, 0x45, 0x8f, 0xbf, 0x3b, 0xa8, 0xcb, 0x4d, 0xa5, 0x55, 0xe9, 0x5c, 0x9a,
	0x4f, 0xce, 0x04, 0x21, 0xa4, 0x29, 0xd8, 0x74, 0xa8, 0x3f, 0x36, 0x22, 0xe5, 0xc4, 0xab, 0x95,
	0xa9, 0x57, 0xaf, 0x02, 0x04, 0x1e, 0xe9, 0x51, 0x4c, 0x5d, 0x3f, 0xa8, 0xab, 0x4d, 0xa5, 0xa5,
	0x18, 0x89, 0x93, 0xc6, 0x75, 0x58, 0x4a, 0x02, 0xa2, 0x1a, 0x28, 0xc7, 0x64, 0xcc, 0x2f, 0xa8,
	0x19, 0x6c, 0x89, 0x4e, 0x83, 0x36, 0xc2, 0x83, 0xa1, 0x70, 0xa9, 0x62, 0x88, 0xcd, 0x75, 0xf9,
	0xaa, 0xa4, 0x5f, 0x84, 0xa2, 0x41, 0x70, 0xe0, 0x3a, 0xb3, 0x74, 0xfd, 0x0b, 0xaa, 0x3b, 0x0e,
	0xbb, 0xf1, 0xc6, 0x40, 0xb0, 0x23, 0xe9, 0x57, 0xa0, 0x7c, 0x07, 0x3b, 0xa6, 0x20, 0x61, 0x09,
	0xa4, 0x93, 0xd0, 0x84, 0x74, 0xc2, 0x76, 0x63, 0x0e, 0xae, 0x19, 0xd2, 0x98, 0xed, 0x28, 0x7f,
	0x83, 0x66, 0x48, 0x54, 0xbf, 0x0a, 0xb0, 0xe1, 0x79, 0x83, 0x31, 0xd7, 0xd3, 0x2f, 0x82, 0xba,
	0x6b, 0x39, 0xe6, 0x8c, 0x35, 0x80, 0xc2, 0xb6, 0x35, 0x22, 0xfb, 0x5e, 0x4d, 0x62, 0x8e, 0xba,
	0xed, 0xe3, 0x67, 0x35, 0x59, 0xff, 0x5d, 0x81, 0xca, 0x36, 0xe7, 0x6e, 0x3e, 0xf1, 0x71, 0x48,
	0xc9, 0x53, 0x21, 0xd5, 0x84, 0x8a, 0xe0, 0xf4, 0xe6, 0x00, 0xf7, 0x8e, 0x43, 0x36, 0x93, 0x47,
	0xb1, 0xc4, 0xa3, 0x23, 0x8b, 0x92, 0x30, 0x22, 0x93, 0x47, 0xe8, 0x7f, 0x50, 0x66, 0xa1, 0x28,
	0x10, 0x44, 0x6c, 0xc6, 0x07, 0xd1, 0x57, 0xa1, 0x5d, 0x88, 0xbf, 0x0a, 0xdd, 0x6b, 0x50, 0x3c,
	0xb2, 0x02, 0xea, 0xfa, 0xe3, 0x7a, 0x91, 0x07, 0xc4, 0xd9, 0xf9, 0x01, 0x31, 0x61, 0xd3, 0x88,
	0xe4, 0x19, 0x70, 0xcf, 0x27, 0x98, 0x12, 0x73, 0x83, 0xd6, 0x4b, 0xfc, 0x5a, 0xf1, 0x01, 0xcb,
	0x42, 0x9f, 0x04, 0xc3, 0x01, 0xad, 0x97, 0xb3, 0xb2, 0x30, 0xc1, 0x59, 0xdb, 0xe0, 0xf2, 0x46,
	0xa8, 0xc7, 0x28, 0x7b, 0x66, 0x39, 0x0e, 0xf1, 0xeb, 0x20, 0x28, 0x13, 0x3b, 0x3d, 0x80, 0x82,
	0x90, 0x4c, 0x06, 0xfe, 0x29, 0x54, 0x04, 0xe5, 0x91, 0xe5, 0x24, 0x9d, 0x82, 0x56, 0xa0, 0xc2,
	0xdd, 0x19, 0xfa, 0x4b, 0x41, 0x55, 0x28, 0xf3, 0x03, 0xfe, 0x5d, 0x45, 0xff, 0x86, 0x95, 0xfd,
	0x80, 0xf8, 0x5d, 0x4a, 0xbc, 0x30, 0x25, 0x6b, 0x1a, 0x3a, 0x0d, 0x35, 0x76, 0xf8, 0xd0, 0xa5,
	0x78, 0x10, 0x9d, 0x16, 0xf4, 0x1f, 0x65, 0xa8, 0x6e, 0x0d, 0x07, 0x83, 0x38, 0xb5, 0x2e, 0x83,
	0xca, 0x7c, 0xc8, 0x7d, 0x9c, 0x4a, 0xdb, 0x44, 0xdc, 0xe0, 0xc2, 0xe8, 0xee, 0x6c, 0xfe, 0x7d,
	0x34, 0x5f, 0x6f, 0xca, 0x54, 0x4a, 0x0e, 0x5e, 0x01, 0x95, 0x65, 0x1d, 0x8f, 0x99, 0x4a, 0xe7,
	0xff, 0x0b, 0xf9, 0x35, 0xb8, 0x78, 0xe3, 0x49, 0x7a, 0x0a, 0x2a, 0x22, 0x05, 0x3f, 0x4e, 0xa6,
	0x60, 0x2a, 0x72, 0xa2, 0x7e, 0x26, 0xb3, 0xf4, 0x1a, 0x94, 0xef, 0x59, 0x01, 0xdd, 0x71, 0xbc,
	0x21, 0x65, 0xc9, 0x3c, 0xb0, 0x6c, 0x8b, 0x86, 0xe8, 0x62, 0xc3, 0x1c, 0xeb, 0x3e, 0x7d, 0x1a,
	0x10, 0x1a, 0xe5, 0x82, 0xd8, 0xe9, 0x4f, 0x60, 0x99, 0xa9, 0xb2, 0x77, 0xdf, 0x1f, 0xd2, 0x50,
	0x9f, 0x32, 0x3f, 0x44, 0xfa, 0x7c, 0x83, 0xae, 0x80, 0xc6, 0xc8, 0x8c, 0x28, 0x5c, 0x48, 0xbd,
	0x90, 0xd6, 0x2f, 0xc0, 0xca, 0x3d, 0xd7, 0x3d, 0x76, 0x79, 0xa9, 0x10, 0xf7, 0x8b, 0xb3, 0x52,
	0x4a, 0x66, 0xa5, 0xfe, 0x18, 0xaa, 0x77, 0x5d, 0x6b, 0xb1, 0x20, 0xab, 0x77, 0x9e, 0x4f, 0x9e,
	0x12, 0xbf, 0xcb, 0xfa, 0x82, 0xa8, 0x2a, 0x89, 0x93, 0x49, 0xc7, 0x50, 0xe2, 0x8e, 0xa1, 0x1f,
	0x40, 0x95, 0x05, 0x18, 0x33, 0xb0, 0x39, 0x22, 0x0e, 0x07, 0x1f, 0x06, 0xc4, 0x8f, 0xc1, 0xc5,
	0x6e, 0xa2, 0x2c, 0x27, 0xda, 0xcd, 0x6c, 0x5b, 0x11, 0xc0, 0xd3, 0x6d, 0xa5, 0x05, 0xcb, 0xcc,
	0x00, 0x6f, 0x0f, 0x99, 0x16, 0xf4, 0x4f, 0x45, 0xac, 0x87, 0x5d, 0x25, 0xfb, 0x36, 0xb3, 0x96,
	0xe5, 0x39, 0x96, 0x2f, 0x88, 0x84, 0x12, 0x34, 0x67, 0x9b, 0xfe, 0x40, 0xb0, 0xb0, 0x79, 0x62,
	0xd1, 0x6c, 0xc1, 0xed, 0xb0, 0x26, 0x0b, 0x47, 0x5c, 0x03, 0xf5, 0xd8, 0x72, 0x84, 0xcc, 0x72,
	0xe7, 0xfd, 0xf9, 0xae, 0x8f, 0x6b, 0x78, 0x9b, 0x15, 0x70, 0x83, 0xab, 0xe8, 0x07, 0x00, 0x06,
	0x79, 0x07, 0x40, 0xec, 0xa6, 0xb8, 0xd7, 0x23, 0x9e, 0xe0, 0xa0, 0x64, 0x84, 0x3b, 0xfd, 0x6b,
	0xf1, 0x24, 0x96, 0x18, 0xd9, 0x54, 0x5e, 0x06, 0xf5, 0x08, 0x3b, 0x66, 0x98, 0x5f, 0x0b, 0x2b,
	0x2e, 0x17, 0xd6, 0x77, 0x85, 0x57, 0xf9, 0x95, 0x04, 0xfc, 0x5b, 0x70, 0xd1, 0x8f, 0x42, 0xe4,
	0x1d, 0x80, 0xa1, 0x06, 0x94, 0x04, 0x03, 0xc4, 0x0c, 0x19, 0x99, 0xec, 0xf5, 0x07, 0x70, 0x86,
	0x19, 0xba, 0x6d, 0x05, 0x3d, 0xd7, 0x71, 0x48, 0x8f, 0x12, 0x33, 0x9b, 0x9b, 0x26, 0x54, 0x9e,
	0x61, 0x8b, 0x4e, 0x47, 0x59, 0xf2, 0x48, 0xbf, 0x04, 0x88, 0x41, 0xde, 0xca, 0x85, 0xa7, 0xaf,
	0x01, 0xdc, 0x73, 0xfb, 0x96, 0x23, 0xbc, 0x7e, 0x36, 0x9c, 0x17, 0x99, 0x4c, 0xf9, 0x66, 0xe5,
	0x97, 0xbf, 0x7e, 0x55, 0x0a, 0xbe, 0xda, 0x94, 0x5b, 0x4d, 0x31, 0x3c, 0xea, 0x0f, 0x60, 0x85,
	0xd5, 0x20, 0x51, 0xdc, 0xfe, 0x41, 0x11, 0x63, 0xe5, 0xd4, 0x32, 0xd9, 0xe8, 0xc9, 0x46, 0x1f,
	0xb6, 0xd4, 0x09, 0xd4, 0x62, 0xc8, 0xcc, 0xc2, 0x76, 0x63, 0xb6, 0x3b, 0xe4, 0x28, 0xbd, 0x91,
	0x46, 0xe7, 0x4f, 0x15, 0x2a, 0xac, 0x60, 0x75, 0x89, 0x3f, 0xb2, 0x7a, 0x04, 0x3d, 0x84, 0xf2,
	0x1e, 0xa6, 0xbd, 0x23, 0x76, 0x86, 0xfe, 0x3b, 0x1f, 0x88, 0x0f, 0xd9, 0x8d, 0xf7, 0x72, 0xf4,
	0x20, 0x5d, 0xfb, 0xe1, 0xe5, 0x4f, 0x67, 0x24, 0xf4, 0x05, 0x94, 0xa2, 0x1a, 0x8d, 0x52, 0x02,
	0x77, 0x52, 0xfe, 0x1b, 0xe7, 0xd2, 0x05, 0xe2, 0x22, 0x2f, 0x90, 0x65, 0x74, 0xc0, 0x1c, 0x15,
	0x95, 0x67, 0x94, 0x12, 0x80, 0x33, 0x05, 0xfc, 0x0d, 0xae, 0xae, 0xa0, 0xc7, 0x50, 0x8a, 0x8a,
	0x3a, 0x4a, 0xd1, 0x9b, 0x2a, 0xfa, 0x6f, 0x00, 0xae, 0xa2, 0x3b, 0xe1, 0x38, 0x9e, 0xcd, 0x74,
	0xd6, 0x47, 0x81, 0xa4, 0xb1, 0x11, 0x21, 0xac, 0xc7, 0x6f, 0x8b, 0x55, 0x40, 0xbb, 0x50, 0x62,
	0x05, 0x76, 0x71, 0x08, 0x2c, 0x06, 0x2b, 0x36, 0xb4, 0xef, 0x59, 0x04, 0x74, 0x5e, 0x28, 0x00,
	0x0c, 0x90, 0xa7, 0x5d, 0x80, 0xba, 0x50, 0x8a, 0xba, 0x59, 0x1a, 0xab, 0x53, 0xdd, 0x2e, 0x87,
	0x29, 0x09, 0xed, 0x43, 0x79, 0xd2, 0xc1, 0xd0, 0xb9, 0x74, 0xd4, 0xb8, 0xc5, 0xe5, 0x80, 0x95,
	0xd1, 0x97, 0x50, 0x49, 0xb4, 0x3b, 0x74, 0x3e, 0x1d, 0x38, 0xd9, 0x11, 0x73, 0x40, 0x2b, 0xe8,
	0x11, 0x40, 0xdc, 0xf9, 0xd2, 0xa2, 0x77, 0xa6, 0x37, 0xe6, 0x00, 0x56, 0x23, 0x7e, 0x99, 0x1b,
	0xb3, 0xf8, 0x9d, 0xf4, 0xd1, 0x3c, 0x31, 0x26, 0x5c, 0x29, 0x77, 0xbe, 0x93, 0xa1, 0x2a, 0x06,
	0xc4, 0xa8, 0x68, 0xec, 0x82, 0xca, 0x8a, 0x0b, 0x5a, 0xd4, 0x93, 0x72, 0x79, 0x71, 0x0f, 0x34,
	0xde, 0x30, 0x50, 0x33, 0xa3, 0x9b, 0x88, 0x54, 0xcb, 0xe3, 0xbd, 0x3d, 0x96, 0x62, 0x19, 0x70,
	0x71, 0x73, 0xcf, 0xe3, 0x31, 0xc1, 0x81, 0xd2, 0x79, 0xae, 0xc1, 0x92, 0xe0, 0x20, 0x0c, 0x68,
	0x03, 0xca, 0xdb, 0xd8, 0x26, 0x5d, 0x8a, 0x7d, 0x8a, 0x16, 0x4f, 0xd5, 0xb9, 0x98, 0x08, 0x9d,
	0xc8, 0xa9, 0xcd, 0x70, 0xe2, 0x64, 0x72, 0xc8, 0xc5, 0x47, 0x98, 0x24, 0x82, 0xe2, 0x8c, 0x24,
	0x89, 0x27, 0x86, 0x5c, 0x91, 0x3c, 0xc9, 0xbd, 0x05, 0xb0, 0xf1, 0xec, 0x90, 0x2b, 0x8e, 0x7b,
	0x62, 0xd4, 0x4c, 0x0e, 0x02, 0xe8, 0xc3, 0x74, 0xf4, 0xd7, 0x06, 0x86, 0x5c, 0xb5, 0xf3, 0x89,
	0x98, 0xc0, 0x26, 0xa3, 0x01, 0x6a, 0xa5, 0x5b, 0xb8, 0xf5, 0xa6, 0xf0, 0x05, 0xf4, 0x00, 0x4a,
	0x2c, 0x34, 0xee, 0x8f, 0x88, 0xff, 0x6e, 0x22, 0x23, 0x2c, 0xaa, 0x6a, 0xe7, 0x37, 0x09, 0xaa,
	0xa2, 0xab, 0x47, 0x99, 0xd8, 0x05, 0x8d, 0xcf, 0x2d, 0x69, 0xd1, 0x1e, 0x0f, 0x35, 0x8d, 0xc5,
	0x53, 0x42, 0x14, 0x87, 0xdf, 0x88, 0xee, 0xcd, 0x9e, 0x9f, 0xda, 0x61, 0xa7, 0xa7, 0x9f, 0xc6,
	0xf9, 0x45, 0x62, 0x53, 0x5d, 0x5c, 0xbc, 0x47, 0xeb, 0xd8, 0xd1, 0x3f, 0x99, 0x61, 0x52, 0x7d,
	0x0e, 0x55, 0xf1, 0x4b, 0xd7, 0xbe, 0x67, 0x62, 0xe6, 0x98, 0xc5, 0x77, 0xce, 0x93, 0x58, 0xc2,
	0x5c, 0xe1, 0xe6, 0xd6, 0x8b, 0x57, 0xab, 0xd2, 0xcb, 0x57, 0xab, 0xd2, 0x1f, 0xaf, 0x56, 0xa5,
	0xaf, 0xae, 0x26, 0x7e, 0x91, 0xc4, 0x3d, 0x1f, 0x7f, 0x6b, 0x39, 0x7d, 0xfe, 0xeb, 0xe2, 0x5a,
	0xdf, 0x5d, 0x4f, 0xfd, 0xad, 0xf3, 0x86, 0x77, 0x78, 0x58, 0xe0, 0x3f, 0x3f, 0x5e, 0xfe, 0x3b,
	0x00, 0x00, 0xff, 0xff, 0x9d, 0xea, 0xef, 0x0f, 0x12, 0x15, 0x00, 0x00,
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *PlayerModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReadyTimeout != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.ReadyTimeout))
		i--
		dAtA[i] = 0x38
	}
	if m.GameId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x30
	}
	if m.Seat != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Seat))
		i--
		dAtA[i] = 0x28
	}
	if m.RoomId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGomoku(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoomModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoomModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Spectators) > 0 {
		dAtA2 := make([]byte, len(m.Spectators)*10)
		var j1 int
		for _, num1 := range m.Spectators {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintGomoku(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if m.GameId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Players) > 0 {
		for k := range m.Players {
			v := m.Players[k]
			baseI := i
			i = encodeVarintGomoku(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintGomoku(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintGomoku(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HandModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HandModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.T != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.T))
		i--
		dAtA[i] = 0x18
	}
	if m.Y != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ApplyModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GomokuModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GomokuModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GomokuModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Winner != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Winner))
		i--
		dAtA[i] = 0x50
	}
	if m.Result != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x48
	}
	if m.CreatedAt != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.History) > 0 {
		for iNdEx := len(m.History) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.History[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGomoku(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.SeatWhite != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.SeatWhite))
		i--
		dAtA[i] = 0x30
	}
	if m.SeatBlack != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.SeatBlack))
		i--
		dAtA[i] = 0x28
	}
	if m.PlayerWhite != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.PlayerWhite))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerBlack != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.PlayerBlack))
		i--
		dAtA[i] = 0x18
	}
	if m.RoomId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FullRoomModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FullRoomModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FullRoomModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Game != nil {
		{
			size, err := m.Game.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGomoku(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Players) > 0 {
		for k := range m.Players {
			v := m.Players[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintGomoku(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintGomoku(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintGomoku(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Room != nil {
		{
			size, err := m.Room.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGomoku(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Offset != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListRoomOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRoomOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRoomOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rooms) > 0 {
		for iNdEx := len(m.Rooms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rooms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGomoku(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Total != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LookonRoomInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LookonRoomInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LookonRoomInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoomId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JoinRoomInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinRoomInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinRoomInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Seat != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Seat))
		i--
		dAtA[i] = 0x18
	}
	if m.PreferSeat != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.PreferSeat))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserJoinEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserJoinEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserJoinEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReadyTimeout != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.ReadyTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.Seat != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Seat))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserReadyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserReadyEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserReadyEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserUnreadyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserUnreadyEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserUnreadyEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReadyTimeout != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.ReadyTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserLookonEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserLookonEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserLookonEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserExitEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserExitEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserExitEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ApplyInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplyInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Kind != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplyInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplyInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Accept {
		i--
		if m.Accept {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserPlayEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPlayEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPlayEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Hand != nil {
		{
			size, err := m.Hand.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGomoku(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.UserId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserApplyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApplyEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApplyEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Kind != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserReplyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserReplyEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserReplyEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Accepted {
		i--
		if m.Accepted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserDisconnectedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDisconnectedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserDisconnectedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WaitTimeout != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.WaitTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserConnectedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserConnectedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserConnectedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoginInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGomoku(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListPlayerInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListPlayerInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListPlayerInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ids) > 0 {
		dAtA8 := make([]byte, len(m.Ids)*10)
		var j7 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintGomoku(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x1a
	}
	if m.Offset != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListPlayerOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListPlayerOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListPlayerOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Players) > 0 {
		for iNdEx := len(m.Players) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Players[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGomoku(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Total != 0 {
		i = encodeVarintGomoku(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGomoku(dAtA []byte, offset int, v uint64) int {
	offset -= sovGomoku(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGomoku(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGomoku(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGomoku(uint64(m.Status))
	}
	if m.RoomId != 0 {
		n += 1 + sovGomoku(uint64(m.RoomId))
	}
	if m.Seat != 0 {
		n += 1 + sovGomoku(uint64(m.Seat))
	}
	if m.GameId != 0 {
		n += 1 + sovGomoku(uint64(m.GameId))
	}
	if m.ReadyTimeout != 0 {
		n += 1 + sovGomoku(uint64(m.ReadyTimeout))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGomoku(uint64(m.Id))
	}
	if len(m.Players) > 0 {
		for k, v := range m.Players {
			_ = k
			_ = v
			mapEntrySize := 1 + sovGomoku(uint64(k)) + 1 + sovGomoku(uint64(v))
			n += mapEntrySize + 1 + sovGomoku(uint64(mapEntrySize))
		}
	}
	if m.GameId != 0 {
		n += 1 + sovGomoku(uint64(m.GameId))
	}
	if len(m.Spectators) > 0 {
		l = 0
		for _, e := range m.Spectators {
			l += sovGomoku(uint64(e))
		}
		n += 1 + sovGomoku(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HandModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovGomoku(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovGomoku(uint64(m.Y))
	}
	if m.T != 0 {
		n += 1 + sovGomoku(uint64(m.T))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ApplyModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GomokuModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGomoku(uint64(m.Id))
	}
	if m.RoomId != 0 {
		n += 1 + sovGomoku(uint64(m.RoomId))
	}
	if m.PlayerBlack != 0 {
		n += 1 + sovGomoku(uint64(m.PlayerBlack))
	}
	if m.PlayerWhite != 0 {
		n += 1 + sovGomoku(uint64(m.PlayerWhite))
	}
	if m.SeatBlack != 0 {
		n += 1 + sovGomoku(uint64(m.SeatBlack))
	}
	if m.SeatWhite != 0 {
		n += 1 + sovGomoku(uint64(m.SeatWhite))
	}
	if len(m.History) > 0 {
		for _, e := range m.History {
			l = e.Size()
			n += 1 + l + sovGomoku(uint64(l))
		}
	}
	if m.CreatedAt != 0 {
		n += 1 + sovGomoku(uint64(m.CreatedAt))
	}
	if m.Result != 0 {
		n += 1 + sovGomoku(uint64(m.Result))
	}
	if m.Winner != 0 {
		n += 1 + sovGomoku(uint64(m.Winner))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FullRoomModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Room != nil {
		l = m.Room.Size()
		n += 1 + l + sovGomoku(uint64(l))
	}
	if len(m.Players) > 0 {
		for k, v := range m.Players {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGomoku(uint64(l))
			}
			mapEntrySize := 1 + sovGomoku(uint64(k)) + l
			n += mapEntrySize + 1 + sovGomoku(uint64(mapEntrySize))
		}
	}
	if m.Game != nil {
		l = m.Game.Size()
		n += 1 + l + sovGomoku(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovGomoku(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovGomoku(uint64(m.Offset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRoomOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovGomoku(uint64(m.Total))
	}
	if len(m.Rooms) > 0 {
		for _, e := range m.Rooms {
			l = e.Size()
			n += 1 + l + sovGomoku(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LookonRoomInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovGomoku(uint64(m.RoomId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JoinRoomInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovGomoku(uint64(m.RoomId))
	}
	if m.PreferSeat != 0 {
		n += 1 + sovGomoku(uint64(m.PreferSeat))
	}
	if m.Seat != 0 {
		n += 1 + sovGomoku(uint64(m.Seat))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserJoinEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovGomoku(uint64(m.UserId))
	}
	if m.Seat != 0 {
		n += 1 + sovGomoku(uint64(m.Seat))
	}
	if m.ReadyTimeout != 0 {
		n += 1 + sovGomoku(uint64(m.ReadyTimeout))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserReadyEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovGomoku(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserUnreadyEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovGomoku(uint64(m.UserId))
	}
	if m.ReadyTimeout != 0 {
		n += 1 + sovGomoku(uint64(m.ReadyTimeout))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserLookonEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovGomoku(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserExitEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovGomoku(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ApplyInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovGomoku(uint64(m.Kind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplyInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovGomoku(uint64(m.Kind))
	}
	if m.Accept {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserPlayEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovGomoku(uint64(m.UserId))
	}
	if m.Hand != nil {
		l = m.Hand.Size()
		n += 1 + l + sovGomoku(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserApplyEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovGomoku(uint64(m.Kind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserReplyEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovGomoku(uint64(m.Kind))
	}
	if m.Accepted {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserDisconnectedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovGomoku(uint64(m.UserId))
	}
	if m.WaitTimeout != 0 {
		n += 1 + sovGomoku(uint64(m.WaitTimeout))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserConnectedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovGomoku(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoginInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGomoku(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListPlayerInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovGomoku(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovGomoku(uint64(m.Offset))
	}
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovGomoku(uint64(e))
		}
		n += 1 + sovGomoku(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListPlayerOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovGomoku(uint64(m.Total))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovGomoku(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGomoku(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGomoku(x uint64) (n int) {
	return sovGomoku(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGomoku
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGomoku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PlayerModel_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyTimeout", wireType)
			}
			m.ReadyTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadyTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGomoku
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGomoku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Players == nil {
				m.Players = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGomoku
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGomoku
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGomoku
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGomoku(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGomoku
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Players[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGomoku
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Spectators = append(m.Spectators, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGomoku
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGomoku
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGomoku
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Spectators) == 0 {
					m.Spectators = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGomoku
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Spectators = append(m.Spectators, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Spectators", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			m.T = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GomokuModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GomokuModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GomokuModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerBlack", wireType)
			}
			m.PlayerBlack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerBlack |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerWhite", wireType)
			}
			m.PlayerWhite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerWhite |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatBlack", wireType)
			}
			m.SeatBlack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatBlack |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatWhite", wireType)
			}
			m.SeatWhite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatWhite |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGomoku
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGomoku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.History = append(m.History, &HandModel{})
			if err := m.History[len(m.History)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= GomokuModel_Result(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Winner", wireType)
			}
			m.Winner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Winner |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FullRoomModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FullRoomModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FullRoomModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGomoku
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGomoku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Room == nil {
				m.Room = &RoomModel{}
			}
			if err := m.Room.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGomoku
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGomoku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Players == nil {
				m.Players = make(map[int64]*PlayerModel)
			}
			var mapkey int64
			var mapvalue *PlayerModel
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGomoku
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGomoku
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGomoku
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGomoku
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGomoku
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PlayerModel{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGomoku(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGomoku
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Players[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Game", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGomoku
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGomoku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Game == nil {
				m.Game = &GomokuModel{}
			}
			if err := m.Game.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRoomOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRoomOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRoomOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rooms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGomoku
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGomoku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rooms = append(m.Rooms, &RoomModel{})
			if err := m.Rooms[len(m.Rooms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookonRoomInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookonRoomInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookonRoomInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinRoomInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinRoomInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinRoomInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferSeat", wireType)
			}
			m.PreferSeat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreferSeat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserJoinEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserJoinEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserJoinEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyTimeout", wireType)
			}
			m.ReadyTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadyTimeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserReadyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserReadyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserReadyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserUnreadyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserUnreadyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserUnreadyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyTimeout", wireType)
			}
			m.ReadyTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadyTimeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserLookonEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserLookonEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserLookonEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserExitEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserExitEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserExitEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= ApplyModel_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= ApplyModel_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accept", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Accept = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPlayEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPlayEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPlayEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGomoku
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGomoku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hand == nil {
				m.Hand = &HandModel{}
			}
			if err := m.Hand.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApplyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApplyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApplyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= ApplyModel_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserReplyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserReplyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserReplyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= ApplyModel_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accepted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Accepted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDisconnectedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDisconnectedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDisconnectedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeout", wireType)
			}
			m.WaitTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserConnectedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserConnectedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserConnectedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGomoku
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGomoku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPlayerInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPlayerInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPlayerInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGomoku
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGomoku
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGomoku
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGomoku
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGomoku
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPlayerOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPlayerOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPlayerOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGomoku
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGomoku
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &PlayerModel{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGomoku(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGomoku
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGomoku(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGomoku
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGomoku
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGomoku
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGomoku
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGomoku
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGomoku        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGomoku          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGomoku = fmt.Errorf("proto: unexpected end of group")
)
