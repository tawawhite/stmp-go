// Code generated by protoc-gen-stmp. DO NOT EDIT.
// source: examples/gomoku/gomoku_pb/gomoku.proto
package pb

import (
	"context"
	"github.com/acrazing/stmp-go/stmp"
)


func init() {
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomService.MatchRoom", 0x101, func() interface{} { return &Empty{} }, func() interface{} { return &FullRoomModel{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomService.ListRoom", 0x102, func() interface{} { return &ListInput{} }, func() interface{} { return &ListRoomOutput{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomService.LookonRoom", 0x103, func() interface{} { return &LookonRoomInput{} }, func() interface{} { return &FullRoomModel{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomService.JoinRoom", 0x104, func() interface{} { return &JoinRoomInput{} }, func() interface{} { return &FullRoomModel{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomService.Ready", 0x105, func() interface{} { return &Empty{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomService.Unready", 0x106, func() interface{} { return &Empty{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomService.ExitRoom", 0x107, func() interface{} { return &Empty{} }, func() interface{} { return &Empty{} })
}

type STMPRoomServiceServer interface {
	MatchRoom(ctx context.Context, in *Empty) (out *FullRoomModel, err error)
	ListRoom(ctx context.Context, in *ListInput) (out *ListRoomOutput, err error)
	LookonRoom(ctx context.Context, in *LookonRoomInput) (out *FullRoomModel, err error)
	JoinRoom(ctx context.Context, in *JoinRoomInput) (out *FullRoomModel, err error)
	Ready(ctx context.Context, in *Empty) (out *Empty, err error)
	Unready(ctx context.Context, in *Empty) (out *Empty, err error)
	ExitRoom(ctx context.Context, in *Empty) (out *Empty, err error)
}

func STMPRegisterRoomServiceServer(srv *stmp.Server, s STMPRoomServiceServer) {
	srv.Handle("stmp.examples.gomoku.RoomService.MatchRoom", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPRoomServiceServer).MatchRoom(ctx, in.(*Empty)) })
	srv.Handle("stmp.examples.gomoku.RoomService.ListRoom", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPRoomServiceServer).ListRoom(ctx, in.(*ListInput)) })
	srv.Handle("stmp.examples.gomoku.RoomService.LookonRoom", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPRoomServiceServer).LookonRoom(ctx, in.(*LookonRoomInput)) })
	srv.Handle("stmp.examples.gomoku.RoomService.JoinRoom", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPRoomServiceServer).JoinRoom(ctx, in.(*JoinRoomInput)) })
	srv.Handle("stmp.examples.gomoku.RoomService.Ready", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPRoomServiceServer).Ready(ctx, in.(*Empty)) })
	srv.Handle("stmp.examples.gomoku.RoomService.Unready", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPRoomServiceServer).Unready(ctx, in.(*Empty)) })
	srv.Handle("stmp.examples.gomoku.RoomService.ExitRoom", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPRoomServiceServer).ExitRoom(ctx, in.(*Empty)) })
}

type STMPRoomServiceClient interface {
	MatchRoom(ctx context.Context, in *Empty, opts ...*stmp.CallOptions) (*FullRoomModel, error)
	ListRoom(ctx context.Context, in *ListInput, opts ...*stmp.CallOptions) (*ListRoomOutput, error)
	LookonRoom(ctx context.Context, in *LookonRoomInput, opts ...*stmp.CallOptions) (*FullRoomModel, error)
	JoinRoom(ctx context.Context, in *JoinRoomInput, opts ...*stmp.CallOptions) (*FullRoomModel, error)
	Ready(ctx context.Context, in *Empty, opts ...*stmp.CallOptions) (*Empty, error)
	Unready(ctx context.Context, in *Empty, opts ...*stmp.CallOptions) (*Empty, error)
	ExitRoom(ctx context.Context, in *Empty, opts ...*stmp.CallOptions) (*Empty, error)
}

type stmpRoomServiceClient struct {
	c *stmp.Client
}

func (s *stmpRoomServiceClient) MatchRoom(ctx context.Context, in *Empty, opts ...*stmp.CallOptions) (*FullRoomModel, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.RoomService.MatchRoom", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*FullRoomModel)(nil), err } else { return out.(*FullRoomModel), err }
}

func (s *stmpRoomServiceClient) ListRoom(ctx context.Context, in *ListInput, opts ...*stmp.CallOptions) (*ListRoomOutput, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.RoomService.ListRoom", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*ListRoomOutput)(nil), err } else { return out.(*ListRoomOutput), err }
}

func (s *stmpRoomServiceClient) LookonRoom(ctx context.Context, in *LookonRoomInput, opts ...*stmp.CallOptions) (*FullRoomModel, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.RoomService.LookonRoom", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*FullRoomModel)(nil), err } else { return out.(*FullRoomModel), err }
}

func (s *stmpRoomServiceClient) JoinRoom(ctx context.Context, in *JoinRoomInput, opts ...*stmp.CallOptions) (*FullRoomModel, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.RoomService.JoinRoom", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*FullRoomModel)(nil), err } else { return out.(*FullRoomModel), err }
}

func (s *stmpRoomServiceClient) Ready(ctx context.Context, in *Empty, opts ...*stmp.CallOptions) (*Empty, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.RoomService.Ready", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*Empty)(nil), err } else { return out.(*Empty), err }
}

func (s *stmpRoomServiceClient) Unready(ctx context.Context, in *Empty, opts ...*stmp.CallOptions) (*Empty, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.RoomService.Unready", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*Empty)(nil), err } else { return out.(*Empty), err }
}

func (s *stmpRoomServiceClient) ExitRoom(ctx context.Context, in *Empty, opts ...*stmp.CallOptions) (*Empty, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.RoomService.ExitRoom", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*Empty)(nil), err } else { return out.(*Empty), err }
}

func STMPNewRoomServiceClient(c *stmp.Client) STMPRoomServiceClient {
	return &stmpRoomServiceClient{c: c}
}



func init() {
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomEvents.UserJoin", 0x201, func() interface{} { return &UserJoinEvent{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomEvents.UserReady", 0x202, func() interface{} { return &UserReadyEvent{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomEvents.UserUnready", 0x203, func() interface{} { return &UserUnreadyEvent{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomEvents.UserLookon", 0x204, func() interface{} { return &UserLookonEvent{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.RoomEvents.UserExit", 0x205, func() interface{} { return &UserExitEvent{} }, func() interface{} { return &Empty{} })
}


type STMPRoomEventsListener interface {
	HandleUserJoin(ctx context.Context, in *UserJoinEvent)
	HandleUserReady(ctx context.Context, in *UserReadyEvent)
	HandleUserUnready(ctx context.Context, in *UserUnreadyEvent)
	HandleUserLookon(ctx context.Context, in *UserLookonEvent)
	HandleUserExit(ctx context.Context, in *UserExitEvent)
}

func STMPAttachRoomEventsListener(c *stmp.Client, s STMPRoomEventsListener) {
	c.Lock()
	c.AddListener("stmp.examples.gomoku.RoomEvents.UserJoin", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPRoomEventsListener).HandleUserJoin(ctx, in.(*UserJoinEvent)) })
	c.AddListener("stmp.examples.gomoku.RoomEvents.UserReady", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPRoomEventsListener).HandleUserReady(ctx, in.(*UserReadyEvent)) })
	c.AddListener("stmp.examples.gomoku.RoomEvents.UserUnready", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPRoomEventsListener).HandleUserUnready(ctx, in.(*UserUnreadyEvent)) })
	c.AddListener("stmp.examples.gomoku.RoomEvents.UserLookon", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPRoomEventsListener).HandleUserLookon(ctx, in.(*UserLookonEvent)) })
	c.AddListener("stmp.examples.gomoku.RoomEvents.UserExit", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPRoomEventsListener).HandleUserExit(ctx, in.(*UserExitEvent)) })
	c.Unlock()
}

func STMPDetachRoomEventsListener(c *stmp.Client, s STMPRoomEventsListener) {
	c.Lock()
	c.RemoveListener("stmp.examples.gomoku.RoomEvents.UserJoin", s)
	c.RemoveListener("stmp.examples.gomoku.RoomEvents.UserReady", s)
	c.RemoveListener("stmp.examples.gomoku.RoomEvents.UserUnready", s)
	c.RemoveListener("stmp.examples.gomoku.RoomEvents.UserLookon", s)
	c.RemoveListener("stmp.examples.gomoku.RoomEvents.UserExit", s)
	c.Unlock()
}

type STMPRoomEventsBroadcaster struct{}

func (s STMPRoomEventsBroadcaster) UserJoin(ctx context.Context, in *UserJoinEvent, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.RoomEvents.UserJoin", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPRoomEventsBroadcaster) UserJoinToList(ctx context.Context, in *UserJoinEvent, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.RoomEvents.UserJoin", payload, stmp.NotifyOptions)
	}
}

func (s STMPRoomEventsBroadcaster) UserJoinToSet(ctx context.Context, in *UserJoinEvent, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.RoomEvents.UserJoin", payload, stmp.NotifyOptions)
	}
}

func (s STMPRoomEventsBroadcaster) UserJoinToAll(ctx context.Context, in *UserJoinEvent, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.RoomEvents.UserJoin", in, filter...) }

func (s STMPRoomEventsBroadcaster) UserReady(ctx context.Context, in *UserReadyEvent, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.RoomEvents.UserReady", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPRoomEventsBroadcaster) UserReadyToList(ctx context.Context, in *UserReadyEvent, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.RoomEvents.UserReady", payload, stmp.NotifyOptions)
	}
}

func (s STMPRoomEventsBroadcaster) UserReadyToSet(ctx context.Context, in *UserReadyEvent, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.RoomEvents.UserReady", payload, stmp.NotifyOptions)
	}
}

func (s STMPRoomEventsBroadcaster) UserReadyToAll(ctx context.Context, in *UserReadyEvent, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.RoomEvents.UserReady", in, filter...) }

func (s STMPRoomEventsBroadcaster) UserUnready(ctx context.Context, in *UserUnreadyEvent, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.RoomEvents.UserUnready", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPRoomEventsBroadcaster) UserUnreadyToList(ctx context.Context, in *UserUnreadyEvent, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.RoomEvents.UserUnready", payload, stmp.NotifyOptions)
	}
}

func (s STMPRoomEventsBroadcaster) UserUnreadyToSet(ctx context.Context, in *UserUnreadyEvent, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.RoomEvents.UserUnready", payload, stmp.NotifyOptions)
	}
}

func (s STMPRoomEventsBroadcaster) UserUnreadyToAll(ctx context.Context, in *UserUnreadyEvent, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.RoomEvents.UserUnready", in, filter...) }

func (s STMPRoomEventsBroadcaster) UserLookon(ctx context.Context, in *UserLookonEvent, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.RoomEvents.UserLookon", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPRoomEventsBroadcaster) UserLookonToList(ctx context.Context, in *UserLookonEvent, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.RoomEvents.UserLookon", payload, stmp.NotifyOptions)
	}
}

func (s STMPRoomEventsBroadcaster) UserLookonToSet(ctx context.Context, in *UserLookonEvent, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.RoomEvents.UserLookon", payload, stmp.NotifyOptions)
	}
}

func (s STMPRoomEventsBroadcaster) UserLookonToAll(ctx context.Context, in *UserLookonEvent, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.RoomEvents.UserLookon", in, filter...) }

func (s STMPRoomEventsBroadcaster) UserExit(ctx context.Context, in *UserExitEvent, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.RoomEvents.UserExit", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPRoomEventsBroadcaster) UserExitToList(ctx context.Context, in *UserExitEvent, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.RoomEvents.UserExit", payload, stmp.NotifyOptions)
	}
}

func (s STMPRoomEventsBroadcaster) UserExitToSet(ctx context.Context, in *UserExitEvent, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.RoomEvents.UserExit", payload, stmp.NotifyOptions)
	}
}

func (s STMPRoomEventsBroadcaster) UserExitToAll(ctx context.Context, in *UserExitEvent, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.RoomEvents.UserExit", in, filter...) }



func init() {
	stmp.RegisterMethodAction("stmp.examples.gomoku.GomokuService.Play", 0x301, func() interface{} { return &HandModel{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.GomokuService.Apply", 0x302, func() interface{} { return &ApplyInput{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.GomokuService.Reply", 0x303, func() interface{} { return &ReplyInput{} }, func() interface{} { return &Empty{} })
}

type STMPGomokuServiceServer interface {
	Play(ctx context.Context, in *HandModel) (out *Empty, err error)
	Apply(ctx context.Context, in *ApplyInput) (out *Empty, err error)
	Reply(ctx context.Context, in *ReplyInput) (out *Empty, err error)
}

func STMPRegisterGomokuServiceServer(srv *stmp.Server, s STMPGomokuServiceServer) {
	srv.Handle("stmp.examples.gomoku.GomokuService.Play", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPGomokuServiceServer).Play(ctx, in.(*HandModel)) })
	srv.Handle("stmp.examples.gomoku.GomokuService.Apply", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPGomokuServiceServer).Apply(ctx, in.(*ApplyInput)) })
	srv.Handle("stmp.examples.gomoku.GomokuService.Reply", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPGomokuServiceServer).Reply(ctx, in.(*ReplyInput)) })
}

type STMPGomokuServiceClient interface {
	Play(ctx context.Context, in *HandModel, opts ...*stmp.CallOptions) (*Empty, error)
	Apply(ctx context.Context, in *ApplyInput, opts ...*stmp.CallOptions) (*Empty, error)
	Reply(ctx context.Context, in *ReplyInput, opts ...*stmp.CallOptions) (*Empty, error)
}

type stmpGomokuServiceClient struct {
	c *stmp.Client
}

func (s *stmpGomokuServiceClient) Play(ctx context.Context, in *HandModel, opts ...*stmp.CallOptions) (*Empty, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.GomokuService.Play", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*Empty)(nil), err } else { return out.(*Empty), err }
}

func (s *stmpGomokuServiceClient) Apply(ctx context.Context, in *ApplyInput, opts ...*stmp.CallOptions) (*Empty, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.GomokuService.Apply", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*Empty)(nil), err } else { return out.(*Empty), err }
}

func (s *stmpGomokuServiceClient) Reply(ctx context.Context, in *ReplyInput, opts ...*stmp.CallOptions) (*Empty, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.GomokuService.Reply", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*Empty)(nil), err } else { return out.(*Empty), err }
}

func STMPNewGomokuServiceClient(c *stmp.Client) STMPGomokuServiceClient {
	return &stmpGomokuServiceClient{c: c}
}



func init() {
	stmp.RegisterMethodAction("stmp.examples.gomoku.GomokuEvents.GameStart", 0x401, func() interface{} { return &GomokuModel{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.GomokuEvents.UserPlay", 0x402, func() interface{} { return &UserPlayEvent{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.GomokuEvents.UserApply", 0x403, func() interface{} { return &UserApplyEvent{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.GomokuEvents.UserReply", 0x404, func() interface{} { return &UserReplyEvent{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.GomokuEvents.UserDisconnected", 0x405, func() interface{} { return &UserDisconnectedEvent{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.GomokuEvents.UserConnected", 0x406, func() interface{} { return &UserConnectedEvent{} }, func() interface{} { return &Empty{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.GomokuEvents.GameOver", 0x407, func() interface{} { return &GomokuModel{} }, func() interface{} { return &Empty{} })
}


type STMPGomokuEventsListener interface {
	HandleGameStart(ctx context.Context, in *GomokuModel)
	HandleUserPlay(ctx context.Context, in *UserPlayEvent)
	HandleUserApply(ctx context.Context, in *UserApplyEvent)
	HandleUserReply(ctx context.Context, in *UserReplyEvent)
	HandleUserDisconnected(ctx context.Context, in *UserDisconnectedEvent)
	HandleUserConnected(ctx context.Context, in *UserConnectedEvent)
	HandleGameOver(ctx context.Context, in *GomokuModel)
}

func STMPAttachGomokuEventsListener(c *stmp.Client, s STMPGomokuEventsListener) {
	c.Lock()
	c.AddListener("stmp.examples.gomoku.GomokuEvents.GameStart", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPGomokuEventsListener).HandleGameStart(ctx, in.(*GomokuModel)) })
	c.AddListener("stmp.examples.gomoku.GomokuEvents.UserPlay", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPGomokuEventsListener).HandleUserPlay(ctx, in.(*UserPlayEvent)) })
	c.AddListener("stmp.examples.gomoku.GomokuEvents.UserApply", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPGomokuEventsListener).HandleUserApply(ctx, in.(*UserApplyEvent)) })
	c.AddListener("stmp.examples.gomoku.GomokuEvents.UserReply", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPGomokuEventsListener).HandleUserReply(ctx, in.(*UserReplyEvent)) })
	c.AddListener("stmp.examples.gomoku.GomokuEvents.UserDisconnected", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPGomokuEventsListener).HandleUserDisconnected(ctx, in.(*UserDisconnectedEvent)) })
	c.AddListener("stmp.examples.gomoku.GomokuEvents.UserConnected", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPGomokuEventsListener).HandleUserConnected(ctx, in.(*UserConnectedEvent)) })
	c.AddListener("stmp.examples.gomoku.GomokuEvents.GameOver", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPGomokuEventsListener).HandleGameOver(ctx, in.(*GomokuModel)) })
	c.Unlock()
}

func STMPDetachGomokuEventsListener(c *stmp.Client, s STMPGomokuEventsListener) {
	c.Lock()
	c.RemoveListener("stmp.examples.gomoku.GomokuEvents.GameStart", s)
	c.RemoveListener("stmp.examples.gomoku.GomokuEvents.UserPlay", s)
	c.RemoveListener("stmp.examples.gomoku.GomokuEvents.UserApply", s)
	c.RemoveListener("stmp.examples.gomoku.GomokuEvents.UserReply", s)
	c.RemoveListener("stmp.examples.gomoku.GomokuEvents.UserDisconnected", s)
	c.RemoveListener("stmp.examples.gomoku.GomokuEvents.UserConnected", s)
	c.RemoveListener("stmp.examples.gomoku.GomokuEvents.GameOver", s)
	c.Unlock()
}

type STMPGomokuEventsBroadcaster struct{}

func (s STMPGomokuEventsBroadcaster) GameStart(ctx context.Context, in *GomokuModel, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.GomokuEvents.GameStart", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPGomokuEventsBroadcaster) GameStartToList(ctx context.Context, in *GomokuModel, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.GameStart", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) GameStartToSet(ctx context.Context, in *GomokuModel, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.GameStart", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) GameStartToAll(ctx context.Context, in *GomokuModel, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.GomokuEvents.GameStart", in, filter...) }

func (s STMPGomokuEventsBroadcaster) UserPlay(ctx context.Context, in *UserPlayEvent, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.GomokuEvents.UserPlay", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPGomokuEventsBroadcaster) UserPlayToList(ctx context.Context, in *UserPlayEvent, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.UserPlay", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) UserPlayToSet(ctx context.Context, in *UserPlayEvent, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.UserPlay", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) UserPlayToAll(ctx context.Context, in *UserPlayEvent, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.GomokuEvents.UserPlay", in, filter...) }

func (s STMPGomokuEventsBroadcaster) UserApply(ctx context.Context, in *UserApplyEvent, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.GomokuEvents.UserApply", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPGomokuEventsBroadcaster) UserApplyToList(ctx context.Context, in *UserApplyEvent, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.UserApply", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) UserApplyToSet(ctx context.Context, in *UserApplyEvent, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.UserApply", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) UserApplyToAll(ctx context.Context, in *UserApplyEvent, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.GomokuEvents.UserApply", in, filter...) }

func (s STMPGomokuEventsBroadcaster) UserReply(ctx context.Context, in *UserReplyEvent, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.GomokuEvents.UserReply", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPGomokuEventsBroadcaster) UserReplyToList(ctx context.Context, in *UserReplyEvent, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.UserReply", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) UserReplyToSet(ctx context.Context, in *UserReplyEvent, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.UserReply", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) UserReplyToAll(ctx context.Context, in *UserReplyEvent, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.GomokuEvents.UserReply", in, filter...) }

func (s STMPGomokuEventsBroadcaster) UserDisconnected(ctx context.Context, in *UserDisconnectedEvent, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.GomokuEvents.UserDisconnected", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPGomokuEventsBroadcaster) UserDisconnectedToList(ctx context.Context, in *UserDisconnectedEvent, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.UserDisconnected", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) UserDisconnectedToSet(ctx context.Context, in *UserDisconnectedEvent, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.UserDisconnected", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) UserDisconnectedToAll(ctx context.Context, in *UserDisconnectedEvent, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.GomokuEvents.UserDisconnected", in, filter...) }

func (s STMPGomokuEventsBroadcaster) UserConnected(ctx context.Context, in *UserConnectedEvent, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.GomokuEvents.UserConnected", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPGomokuEventsBroadcaster) UserConnectedToList(ctx context.Context, in *UserConnectedEvent, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.UserConnected", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) UserConnectedToSet(ctx context.Context, in *UserConnectedEvent, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.UserConnected", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) UserConnectedToAll(ctx context.Context, in *UserConnectedEvent, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.GomokuEvents.UserConnected", in, filter...) }

func (s STMPGomokuEventsBroadcaster) GameOver(ctx context.Context, in *GomokuModel, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.GomokuEvents.GameOver", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPGomokuEventsBroadcaster) GameOverToList(ctx context.Context, in *GomokuModel, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.GameOver", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) GameOverToSet(ctx context.Context, in *GomokuModel, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.GomokuEvents.GameOver", payload, stmp.NotifyOptions)
	}
}

func (s STMPGomokuEventsBroadcaster) GameOverToAll(ctx context.Context, in *GomokuModel, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.GomokuEvents.GameOver", in, filter...) }



func init() {
	stmp.RegisterMethodAction("stmp.examples.gomoku.PlayerService.Login", 0x501, func() interface{} { return &LoginInput{} }, func() interface{} { return &PlayerModel{} })
	stmp.RegisterMethodAction("stmp.examples.gomoku.PlayerService.ListUser", 0x502, func() interface{} { return &ListPlayerInput{} }, func() interface{} { return &ListPlayerOutput{} })
}

type STMPPlayerServiceServer interface {
	Login(ctx context.Context, in *LoginInput) (out *PlayerModel, err error)
	ListUser(ctx context.Context, in *ListPlayerInput) (out *ListPlayerOutput, err error)
}

func STMPRegisterPlayerServiceServer(srv *stmp.Server, s STMPPlayerServiceServer) {
	srv.Handle("stmp.examples.gomoku.PlayerService.Login", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPPlayerServiceServer).Login(ctx, in.(*LoginInput)) })
	srv.Handle("stmp.examples.gomoku.PlayerService.ListUser", s, func(ctx context.Context, in interface{}, inst interface{}) (out interface{}, err error) { return inst.(STMPPlayerServiceServer).ListUser(ctx, in.(*ListPlayerInput)) })
}

type STMPPlayerServiceClient interface {
	Login(ctx context.Context, in *LoginInput, opts ...*stmp.CallOptions) (*PlayerModel, error)
	ListUser(ctx context.Context, in *ListPlayerInput, opts ...*stmp.CallOptions) (*ListPlayerOutput, error)
}

type stmpPlayerServiceClient struct {
	c *stmp.Client
}

func (s *stmpPlayerServiceClient) Login(ctx context.Context, in *LoginInput, opts ...*stmp.CallOptions) (*PlayerModel, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.PlayerService.Login", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*PlayerModel)(nil), err } else { return out.(*PlayerModel), err }
}

func (s *stmpPlayerServiceClient) ListUser(ctx context.Context, in *ListPlayerInput, opts ...*stmp.CallOptions) (*ListPlayerOutput, error) {
	out, err := s.c.Invoke(ctx, "stmp.examples.gomoku.PlayerService.ListUser", in, stmp.PickCallOptions(opts...))
	if out == nil { return (*ListPlayerOutput)(nil), err } else { return out.(*ListPlayerOutput), err }
}

func STMPNewPlayerServiceClient(c *stmp.Client) STMPPlayerServiceClient {
	return &stmpPlayerServiceClient{c: c}
}



func init() {
	stmp.RegisterMethodAction("stmp.examples.gomoku.PlayerEvents.StatusUpdated", 0x601, func() interface{} { return &PlayerModel{} }, func() interface{} { return &Empty{} })
}


type STMPPlayerEventsListener interface {
	HandleStatusUpdated(ctx context.Context, in *PlayerModel)
}

func STMPAttachPlayerEventsListener(c *stmp.Client, s STMPPlayerEventsListener) {
	c.Lock()
	c.AddListener("stmp.examples.gomoku.PlayerEvents.StatusUpdated", s, func(ctx context.Context, in interface{}, inst interface{}) { inst.(STMPPlayerEventsListener).HandleStatusUpdated(ctx, in.(*PlayerModel)) })
	c.Unlock()
}

func STMPDetachPlayerEventsListener(c *stmp.Client, s STMPPlayerEventsListener) {
	c.Lock()
	c.RemoveListener("stmp.examples.gomoku.PlayerEvents.StatusUpdated", s)
	c.Unlock()
}

type STMPPlayerEventsBroadcaster struct{}

func (s STMPPlayerEventsBroadcaster) StatusUpdated(ctx context.Context, in *PlayerModel, conn *stmp.Conn, opts ...*stmp.CallOptions) error {
	_, err := conn.Invoke(ctx, "stmp.examples.gomoku.PlayerEvents.StatusUpdated", in, stmp.PickCallOptions(opts...).Notify())
	return err
}

func (s STMPPlayerEventsBroadcaster) StatusUpdatedToList(ctx context.Context, in *PlayerModel, conns ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for _, conn := range conns {
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.PlayerEvents.StatusUpdated", payload, stmp.NotifyOptions)
	}
}

func (s STMPPlayerEventsBroadcaster) StatusUpdatedToSet(ctx context.Context, in *PlayerModel, conns stmp.ConnSet, exclude ...*stmp.Conn) {
	payloads := stmp.NewPayloadMap(in)
	for conn := range conns {
		for _, e := range exclude {
			if e == conn {
				conn = nil
				break
			}
		}
		if conn == nil {
			continue
		}
		payload, err := payloads.Marshal(conn)
		if err != nil {
			continue
		}
		conn.Call(ctx, "stmp.examples.gomoku.PlayerEvents.StatusUpdated", payload, stmp.NotifyOptions)
	}
}

func (s STMPPlayerEventsBroadcaster) StatusUpdatedToAll(ctx context.Context, in *PlayerModel, srv *stmp.Server, filter ...stmp.ConnFilter) { srv.Broadcast(ctx, "stmp.examples.gomoku.PlayerEvents.StatusUpdated", in, filter...) }



