// Code generated by protoc-gen-stmp. DO NOT EDIT.
// source: examples/gomoku/gomoku_pb/gomoku.proto
const pb = require("./gomoku.pb");
const { PayloadMap, registerMethodAction, notifyOptions } = require("stmp");

const stmp = Object.create(null);

module.exports = stmp;
module.exports.default = module.exports;

function initNamespace(root, ns, factory) {
    for (const item of ns.split(".")) {
        root = (root[item] = root[item] || Object.create(null))
    }
	factory(root)
}

initNamespace(stmp, "stmp.examples.gomoku", (ns) => {


  registerMethodAction("stmp.examples.gomoku.RoomService.MatchRoom", "101", pb.stmp.examples.gomoku.Empty, pb.stmp.examples.gomoku.FullRoomModel);
  registerMethodAction("stmp.examples.gomoku.RoomService.ListRoom", "102", pb.stmp.examples.gomoku.ListInput, pb.stmp.examples.gomoku.ListRoomOutput);
  registerMethodAction("stmp.examples.gomoku.RoomService.LookonRoom", "103", pb.stmp.examples.gomoku.LookonRoomInput, pb.stmp.examples.gomoku.FullRoomModel);
  registerMethodAction("stmp.examples.gomoku.RoomService.JoinRoom", "104", pb.stmp.examples.gomoku.JoinRoomInput, pb.stmp.examples.gomoku.FullRoomModel);
  registerMethodAction("stmp.examples.gomoku.RoomService.Ready", "105", pb.stmp.examples.gomoku.Empty, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.RoomService.Unready", "106", pb.stmp.examples.gomoku.Empty, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.RoomService.ExitRoom", "107", pb.stmp.examples.gomoku.Empty, pb.stmp.examples.gomoku.Empty);

  ns.RoomServiceServer = class RoomServiceServer {
    static register(srv, inst) {
      srv.register(inst, "stmp.examples.gomoku.RoomService.MatchRoom", inst.MatchRoom);
      srv.register(inst, "stmp.examples.gomoku.RoomService.ListRoom", inst.ListRoom);
      srv.register(inst, "stmp.examples.gomoku.RoomService.LookonRoom", inst.LookonRoom);
      srv.register(inst, "stmp.examples.gomoku.RoomService.JoinRoom", inst.JoinRoom);
      srv.register(inst, "stmp.examples.gomoku.RoomService.Ready", inst.Ready);
      srv.register(inst, "stmp.examples.gomoku.RoomService.Unready", inst.Unready);
      srv.register(inst, "stmp.examples.gomoku.RoomService.ExitRoom", inst.ExitRoom);
    }

    static unregister(srv, inst) {
      srv.unregister(inst, "stmp.examples.gomoku.RoomService.MatchRoom");
      srv.unregister(inst, "stmp.examples.gomoku.RoomService.ListRoom");
      srv.unregister(inst, "stmp.examples.gomoku.RoomService.LookonRoom");
      srv.unregister(inst, "stmp.examples.gomoku.RoomService.JoinRoom");
      srv.unregister(inst, "stmp.examples.gomoku.RoomService.Ready");
      srv.unregister(inst, "stmp.examples.gomoku.RoomService.Unready");
      srv.unregister(inst, "stmp.examples.gomoku.RoomService.ExitRoom");
    }

    MatchRoom(ctx, input, output) { throw new Error("not implemented") }
    ListRoom(ctx, input, output) { throw new Error("not implemented") }
    LookonRoom(ctx, input, output) { throw new Error("not implemented") }
    JoinRoom(ctx, input, output) { throw new Error("not implemented") }
    Ready(ctx, input, output) { throw new Error("not implemented") }
    Unready(ctx, input, output) { throw new Error("not implemented") }
    ExitRoom(ctx, input, output) { throw new Error("not implemented") }
  };

  ns.RoomServiceClient = class RoomServiceClient {
    constructor(client) { this.client = client }
    MatchRoom(input, options) { return this.client.invoke("stmp.examples.gomoku.RoomService.MatchRoom", input, options) }
    ListRoom(input, options) { return this.client.invoke("stmp.examples.gomoku.RoomService.ListRoom", input, options) }
    LookonRoom(input, options) { return this.client.invoke("stmp.examples.gomoku.RoomService.LookonRoom", input, options) }
    JoinRoom(input, options) { return this.client.invoke("stmp.examples.gomoku.RoomService.JoinRoom", input, options) }
    Ready(input, options) { return this.client.invoke("stmp.examples.gomoku.RoomService.Ready", input, options) }
    Unready(input, options) { return this.client.invoke("stmp.examples.gomoku.RoomService.Unready", input, options) }
    ExitRoom(input, options) { return this.client.invoke("stmp.examples.gomoku.RoomService.ExitRoom", input, options) }
  };




  registerMethodAction("stmp.examples.gomoku.RoomEvents.UserJoin", "201", pb.stmp.examples.gomoku.UserJoinEvent, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.RoomEvents.UserReady", "202", pb.stmp.examples.gomoku.UserReadyEvent, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.RoomEvents.UserUnready", "203", pb.stmp.examples.gomoku.UserUnreadyEvent, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.RoomEvents.UserLookon", "204", pb.stmp.examples.gomoku.UserLookonEvent, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.RoomEvents.UserExit", "205", pb.stmp.examples.gomoku.UserExitEvent, pb.stmp.examples.gomoku.Empty);


  ns.RoomEventsListener = class RoomEventsListener {
    static register(c, inst) {
      c.register(inst, "stmp.examples.gomoku.RoomEvents.UserJoin", inst.HandleUserJoin);
      c.register(inst, "stmp.examples.gomoku.RoomEvents.UserReady", inst.HandleUserReady);
      c.register(inst, "stmp.examples.gomoku.RoomEvents.UserUnready", inst.HandleUserUnready);
      c.register(inst, "stmp.examples.gomoku.RoomEvents.UserLookon", inst.HandleUserLookon);
      c.register(inst, "stmp.examples.gomoku.RoomEvents.UserExit", inst.HandleUserExit);
    }

    static unregister(c, inst) {
      c.unregister(inst, "stmp.examples.gomoku.RoomEvents.UserJoin");
      c.unregister(inst, "stmp.examples.gomoku.RoomEvents.UserReady");
      c.unregister(inst, "stmp.examples.gomoku.RoomEvents.UserUnready");
      c.unregister(inst, "stmp.examples.gomoku.RoomEvents.UserLookon");
      c.unregister(inst, "stmp.examples.gomoku.RoomEvents.UserExit");
    }

    HandleUserJoin(ctx, input, output) { }
    HandleUserReady(ctx, input, output) { }
    HandleUserUnready(ctx, input, output) { }
    HandleUserLookon(ctx, input, output) { }
    HandleUserExit(ctx, input, output) { }
  };

  ns.RoomEventsBroadcaster = class RoomEventsBroadcaster {
   static UserJoin(input, conn) { return conn.invoke("stmp.examples.gomoku.RoomEvents.UserJoin", input, notifyOptions) }
   static UserJoinToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.RoomEvents.UserJoin", pm.get(conn), notifyOptions) }
   static UserJoinToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.RoomEvents.UserJoin", input, filter) }
   static UserReady(input, conn) { return conn.invoke("stmp.examples.gomoku.RoomEvents.UserReady", input, notifyOptions) }
   static UserReadyToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.RoomEvents.UserReady", pm.get(conn), notifyOptions) }
   static UserReadyToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.RoomEvents.UserReady", input, filter) }
   static UserUnready(input, conn) { return conn.invoke("stmp.examples.gomoku.RoomEvents.UserUnready", input, notifyOptions) }
   static UserUnreadyToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.RoomEvents.UserUnready", pm.get(conn), notifyOptions) }
   static UserUnreadyToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.RoomEvents.UserUnready", input, filter) }
   static UserLookon(input, conn) { return conn.invoke("stmp.examples.gomoku.RoomEvents.UserLookon", input, notifyOptions) }
   static UserLookonToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.RoomEvents.UserLookon", pm.get(conn), notifyOptions) }
   static UserLookonToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.RoomEvents.UserLookon", input, filter) }
   static UserExit(input, conn) { return conn.invoke("stmp.examples.gomoku.RoomEvents.UserExit", input, notifyOptions) }
   static UserExitToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.RoomEvents.UserExit", pm.get(conn), notifyOptions) }
   static UserExitToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.RoomEvents.UserExit", input, filter) }
  };



  registerMethodAction("stmp.examples.gomoku.GomokuService.Play", "301", pb.stmp.examples.gomoku.HandModel, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.GomokuService.Apply", "302", pb.stmp.examples.gomoku.ApplyInput, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.GomokuService.Reply", "303", pb.stmp.examples.gomoku.ReplyInput, pb.stmp.examples.gomoku.Empty);

  ns.GomokuServiceServer = class GomokuServiceServer {
    static register(srv, inst) {
      srv.register(inst, "stmp.examples.gomoku.GomokuService.Play", inst.Play);
      srv.register(inst, "stmp.examples.gomoku.GomokuService.Apply", inst.Apply);
      srv.register(inst, "stmp.examples.gomoku.GomokuService.Reply", inst.Reply);
    }

    static unregister(srv, inst) {
      srv.unregister(inst, "stmp.examples.gomoku.GomokuService.Play");
      srv.unregister(inst, "stmp.examples.gomoku.GomokuService.Apply");
      srv.unregister(inst, "stmp.examples.gomoku.GomokuService.Reply");
    }

    Play(ctx, input, output) { throw new Error("not implemented") }
    Apply(ctx, input, output) { throw new Error("not implemented") }
    Reply(ctx, input, output) { throw new Error("not implemented") }
  };

  ns.GomokuServiceClient = class GomokuServiceClient {
    constructor(client) { this.client = client }
    Play(input, options) { return this.client.invoke("stmp.examples.gomoku.GomokuService.Play", input, options) }
    Apply(input, options) { return this.client.invoke("stmp.examples.gomoku.GomokuService.Apply", input, options) }
    Reply(input, options) { return this.client.invoke("stmp.examples.gomoku.GomokuService.Reply", input, options) }
  };




  registerMethodAction("stmp.examples.gomoku.GomokuEvents.GameStart", "401", pb.stmp.examples.gomoku.GomokuModel, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.GomokuEvents.UserPlay", "402", pb.stmp.examples.gomoku.UserPlayEvent, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.GomokuEvents.UserApply", "403", pb.stmp.examples.gomoku.UserApplyEvent, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.GomokuEvents.UserReply", "404", pb.stmp.examples.gomoku.UserReplyEvent, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.GomokuEvents.UserDisconnected", "405", pb.stmp.examples.gomoku.UserDisconnectedEvent, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.GomokuEvents.UserConnected", "406", pb.stmp.examples.gomoku.UserConnectedEvent, pb.stmp.examples.gomoku.Empty);
  registerMethodAction("stmp.examples.gomoku.GomokuEvents.GameOver", "407", pb.stmp.examples.gomoku.GomokuModel, pb.stmp.examples.gomoku.Empty);


  ns.GomokuEventsListener = class GomokuEventsListener {
    static register(c, inst) {
      c.register(inst, "stmp.examples.gomoku.GomokuEvents.GameStart", inst.HandleGameStart);
      c.register(inst, "stmp.examples.gomoku.GomokuEvents.UserPlay", inst.HandleUserPlay);
      c.register(inst, "stmp.examples.gomoku.GomokuEvents.UserApply", inst.HandleUserApply);
      c.register(inst, "stmp.examples.gomoku.GomokuEvents.UserReply", inst.HandleUserReply);
      c.register(inst, "stmp.examples.gomoku.GomokuEvents.UserDisconnected", inst.HandleUserDisconnected);
      c.register(inst, "stmp.examples.gomoku.GomokuEvents.UserConnected", inst.HandleUserConnected);
      c.register(inst, "stmp.examples.gomoku.GomokuEvents.GameOver", inst.HandleGameOver);
    }

    static unregister(c, inst) {
      c.unregister(inst, "stmp.examples.gomoku.GomokuEvents.GameStart");
      c.unregister(inst, "stmp.examples.gomoku.GomokuEvents.UserPlay");
      c.unregister(inst, "stmp.examples.gomoku.GomokuEvents.UserApply");
      c.unregister(inst, "stmp.examples.gomoku.GomokuEvents.UserReply");
      c.unregister(inst, "stmp.examples.gomoku.GomokuEvents.UserDisconnected");
      c.unregister(inst, "stmp.examples.gomoku.GomokuEvents.UserConnected");
      c.unregister(inst, "stmp.examples.gomoku.GomokuEvents.GameOver");
    }

    HandleGameStart(ctx, input, output) { }
    HandleUserPlay(ctx, input, output) { }
    HandleUserApply(ctx, input, output) { }
    HandleUserReply(ctx, input, output) { }
    HandleUserDisconnected(ctx, input, output) { }
    HandleUserConnected(ctx, input, output) { }
    HandleGameOver(ctx, input, output) { }
  };

  ns.GomokuEventsBroadcaster = class GomokuEventsBroadcaster {
   static GameStart(input, conn) { return conn.invoke("stmp.examples.gomoku.GomokuEvents.GameStart", input, notifyOptions) }
   static GameStartToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.GomokuEvents.GameStart", pm.get(conn), notifyOptions) }
   static GameStartToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.GomokuEvents.GameStart", input, filter) }
   static UserPlay(input, conn) { return conn.invoke("stmp.examples.gomoku.GomokuEvents.UserPlay", input, notifyOptions) }
   static UserPlayToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.GomokuEvents.UserPlay", pm.get(conn), notifyOptions) }
   static UserPlayToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.GomokuEvents.UserPlay", input, filter) }
   static UserApply(input, conn) { return conn.invoke("stmp.examples.gomoku.GomokuEvents.UserApply", input, notifyOptions) }
   static UserApplyToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.GomokuEvents.UserApply", pm.get(conn), notifyOptions) }
   static UserApplyToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.GomokuEvents.UserApply", input, filter) }
   static UserReply(input, conn) { return conn.invoke("stmp.examples.gomoku.GomokuEvents.UserReply", input, notifyOptions) }
   static UserReplyToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.GomokuEvents.UserReply", pm.get(conn), notifyOptions) }
   static UserReplyToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.GomokuEvents.UserReply", input, filter) }
   static UserDisconnected(input, conn) { return conn.invoke("stmp.examples.gomoku.GomokuEvents.UserDisconnected", input, notifyOptions) }
   static UserDisconnectedToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.GomokuEvents.UserDisconnected", pm.get(conn), notifyOptions) }
   static UserDisconnectedToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.GomokuEvents.UserDisconnected", input, filter) }
   static UserConnected(input, conn) { return conn.invoke("stmp.examples.gomoku.GomokuEvents.UserConnected", input, notifyOptions) }
   static UserConnectedToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.GomokuEvents.UserConnected", pm.get(conn), notifyOptions) }
   static UserConnectedToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.GomokuEvents.UserConnected", input, filter) }
   static GameOver(input, conn) { return conn.invoke("stmp.examples.gomoku.GomokuEvents.GameOver", input, notifyOptions) }
   static GameOverToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.GomokuEvents.GameOver", pm.get(conn), notifyOptions) }
   static GameOverToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.GomokuEvents.GameOver", input, filter) }
  };



  registerMethodAction("stmp.examples.gomoku.PlayerService.Login", "501", pb.stmp.examples.gomoku.LoginInput, pb.stmp.examples.gomoku.PlayerModel);
  registerMethodAction("stmp.examples.gomoku.PlayerService.ListUser", "502", pb.stmp.examples.gomoku.ListPlayerInput, pb.stmp.examples.gomoku.ListPlayerOutput);

  ns.PlayerServiceServer = class PlayerServiceServer {
    static register(srv, inst) {
      srv.register(inst, "stmp.examples.gomoku.PlayerService.Login", inst.Login);
      srv.register(inst, "stmp.examples.gomoku.PlayerService.ListUser", inst.ListUser);
    }

    static unregister(srv, inst) {
      srv.unregister(inst, "stmp.examples.gomoku.PlayerService.Login");
      srv.unregister(inst, "stmp.examples.gomoku.PlayerService.ListUser");
    }

    Login(ctx, input, output) { throw new Error("not implemented") }
    ListUser(ctx, input, output) { throw new Error("not implemented") }
  };

  ns.PlayerServiceClient = class PlayerServiceClient {
    constructor(client) { this.client = client }
    Login(input, options) { return this.client.invoke("stmp.examples.gomoku.PlayerService.Login", input, options) }
    ListUser(input, options) { return this.client.invoke("stmp.examples.gomoku.PlayerService.ListUser", input, options) }
  };




  registerMethodAction("stmp.examples.gomoku.PlayerEvents.StatusUpdated", "601", pb.stmp.examples.gomoku.PlayerModel, pb.stmp.examples.gomoku.Empty);


  ns.PlayerEventsListener = class PlayerEventsListener {
    static register(c, inst) {
      c.register(inst, "stmp.examples.gomoku.PlayerEvents.StatusUpdated", inst.HandleStatusUpdated);
    }

    static unregister(c, inst) {
      c.unregister(inst, "stmp.examples.gomoku.PlayerEvents.StatusUpdated");
    }

    HandleStatusUpdated(ctx, input, output) { }
  };

  ns.PlayerEventsBroadcaster = class PlayerEventsBroadcaster {
   static StatusUpdated(input, conn) { return conn.invoke("stmp.examples.gomoku.PlayerEvents.StatusUpdated", input, notifyOptions) }
   static StatusUpdatedToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.gomoku.PlayerEvents.StatusUpdated", pm.get(conn), notifyOptions) }
   static StatusUpdatedToAll(input, srv, filter) { return srv.broadcast("stmp.examples.gomoku.PlayerEvents.StatusUpdated", input, filter) }
  };


});
