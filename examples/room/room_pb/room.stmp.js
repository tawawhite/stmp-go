// Code generated by protoc-gen-stmp. DO NOT EDIT.
// source: examples/room/room_pb/room.proto
const pb = require("./room.pb");
const { PayloadMap, registerMethodAction, notifyOptions } = require("stmp");

const stmp = Object.create(null);

module.exports = stmp;
module.exports.default = module.exports;

function initNamespace(root, ns, factory) {
    for (const item of ns.split(".")) {
        root = (root[item] = root[item] || Object.create(null))
    }
	factory(root)
}

initNamespace(stmp, "stmp.examples.room", (ns) => {


  registerMethodAction("stmp.examples.room.UserService.ListUser", "1001", pb.stmp.examples.room.ListInput, pb.stmp.examples.room.ListUserOutput);
  registerMethodAction("stmp.examples.room.UserService.Login", "1002", pb.stmp.examples.room.LoginInput, pb.stmp.examples.room.UserModel);

  ns.UserServiceServer = class UserServiceServer {
    static register(srv, inst) {
      srv.register(inst, "stmp.examples.room.UserService.ListUser", inst.ListUser);
      srv.register(inst, "stmp.examples.room.UserService.Login", inst.Login);
    }

    static unregister(srv, inst) {
      srv.unregister(inst, "stmp.examples.room.UserService.ListUser");
      srv.unregister(inst, "stmp.examples.room.UserService.Login");
    }

    ListUser(ctx, input, output) { throw new Error("not implemented") }
    Login(ctx, input, output) { throw new Error("not implemented") }
  };

  ns.UserServiceClient = class UserServiceClient {
    constructor(client) { this.client = client }
    ListUser(input, options) { return this.client.invoke("stmp.examples.room.UserService.ListUser", input, options) }
    Login(input, options) { return this.client.invoke("stmp.examples.room.UserService.Login", input, options) }
  };




  registerMethodAction("stmp.examples.room.UserEvents.StatusUpdated", "1101", pb.stmp.examples.room.UserModel, pb.google.protobuf.Empty);


  ns.UserEventsListener = class UserEventsListener {
    static register(c, inst) {
      c.register(inst, "stmp.examples.room.UserEvents.StatusUpdated", inst.HandleStatusUpdated);
    }

    static unregister(c, inst) {
      c.unregister(inst, "stmp.examples.room.UserEvents.StatusUpdated");
    }

    HandleStatusUpdated(ctx, input, output) { }
  };

  ns.UserEventsBroadcaster = class UserEventsBroadcaster {
   static StatusUpdated(input, conn) { return conn.invoke("stmp.examples.room.UserEvents.StatusUpdated", input, notifyOptions) }
   static StatusUpdatedToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.room.UserEvents.StatusUpdated", pm.get(conn), notifyOptions) }
   static StatusUpdatedToAll(input, srv, filter) { return srv.broadcast("stmp.examples.room.UserEvents.StatusUpdated", input, filter) }
  };



  registerMethodAction("stmp.examples.room.RoomService.CreateRoom", "1201", pb.stmp.examples.room.CreateRoomInput, pb.stmp.examples.room.RoomModel);
  registerMethodAction("stmp.examples.room.RoomService.ListRoom", "1202", pb.stmp.examples.room.ListInput, pb.stmp.examples.room.ListRoomOutput);
  registerMethodAction("stmp.examples.room.RoomService.JoinRoom", "1203", pb.stmp.examples.room.JoinRoomInput, pb.stmp.examples.room.RoomModel);
  registerMethodAction("stmp.examples.room.RoomService.ExitRoom", "1204", pb.stmp.examples.room.ExitRoomInput, pb.google.protobuf.Empty);
  registerMethodAction("stmp.examples.room.RoomService.SendMessage", "1205", pb.stmp.examples.room.SendMessageInput, pb.google.protobuf.Empty);

  ns.RoomServiceServer = class RoomServiceServer {
    static register(srv, inst) {
      srv.register(inst, "stmp.examples.room.RoomService.CreateRoom", inst.CreateRoom);
      srv.register(inst, "stmp.examples.room.RoomService.ListRoom", inst.ListRoom);
      srv.register(inst, "stmp.examples.room.RoomService.JoinRoom", inst.JoinRoom);
      srv.register(inst, "stmp.examples.room.RoomService.ExitRoom", inst.ExitRoom);
      srv.register(inst, "stmp.examples.room.RoomService.SendMessage", inst.SendMessage);
    }

    static unregister(srv, inst) {
      srv.unregister(inst, "stmp.examples.room.RoomService.CreateRoom");
      srv.unregister(inst, "stmp.examples.room.RoomService.ListRoom");
      srv.unregister(inst, "stmp.examples.room.RoomService.JoinRoom");
      srv.unregister(inst, "stmp.examples.room.RoomService.ExitRoom");
      srv.unregister(inst, "stmp.examples.room.RoomService.SendMessage");
    }

    CreateRoom(ctx, input, output) { throw new Error("not implemented") }
    ListRoom(ctx, input, output) { throw new Error("not implemented") }
    JoinRoom(ctx, input, output) { throw new Error("not implemented") }
    ExitRoom(ctx, input, output) { throw new Error("not implemented") }
    SendMessage(ctx, input, output) { throw new Error("not implemented") }
  };

  ns.RoomServiceClient = class RoomServiceClient {
    constructor(client) { this.client = client }
    CreateRoom(input, options) { return this.client.invoke("stmp.examples.room.RoomService.CreateRoom", input, options) }
    ListRoom(input, options) { return this.client.invoke("stmp.examples.room.RoomService.ListRoom", input, options) }
    JoinRoom(input, options) { return this.client.invoke("stmp.examples.room.RoomService.JoinRoom", input, options) }
    ExitRoom(input, options) { return this.client.invoke("stmp.examples.room.RoomService.ExitRoom", input, options) }
    SendMessage(input, options) { return this.client.invoke("stmp.examples.room.RoomService.SendMessage", input, options) }
  };




  registerMethodAction("stmp.examples.room.RoomEvents.UserEnter", "1301", pb.stmp.examples.room.UserEnterEvent, pb.google.protobuf.Empty);
  registerMethodAction("stmp.examples.room.RoomEvents.UserExit", "1302", pb.stmp.examples.room.UserExitEvent, pb.google.protobuf.Empty);
  registerMethodAction("stmp.examples.room.RoomEvents.NewMessage", "1303", pb.stmp.examples.room.ChatMessageModel, pb.google.protobuf.Empty);


  ns.RoomEventsListener = class RoomEventsListener {
    static register(c, inst) {
      c.register(inst, "stmp.examples.room.RoomEvents.UserEnter", inst.HandleUserEnter);
      c.register(inst, "stmp.examples.room.RoomEvents.UserExit", inst.HandleUserExit);
      c.register(inst, "stmp.examples.room.RoomEvents.NewMessage", inst.HandleNewMessage);
    }

    static unregister(c, inst) {
      c.unregister(inst, "stmp.examples.room.RoomEvents.UserEnter");
      c.unregister(inst, "stmp.examples.room.RoomEvents.UserExit");
      c.unregister(inst, "stmp.examples.room.RoomEvents.NewMessage");
    }

    HandleUserEnter(ctx, input, output) { }
    HandleUserExit(ctx, input, output) { }
    HandleNewMessage(ctx, input, output) { }
  };

  ns.RoomEventsBroadcaster = class RoomEventsBroadcaster {
   static UserEnter(input, conn) { return conn.invoke("stmp.examples.room.RoomEvents.UserEnter", input, notifyOptions) }
   static UserEnterToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.room.RoomEvents.UserEnter", pm.get(conn), notifyOptions) }
   static UserEnterToAll(input, srv, filter) { return srv.broadcast("stmp.examples.room.RoomEvents.UserEnter", input, filter) }
   static UserExit(input, conn) { return conn.invoke("stmp.examples.room.RoomEvents.UserExit", input, notifyOptions) }
   static UserExitToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.room.RoomEvents.UserExit", pm.get(conn), notifyOptions) }
   static UserExitToAll(input, srv, filter) { return srv.broadcast("stmp.examples.room.RoomEvents.UserExit", input, filter) }
   static NewMessage(input, conn) { return conn.invoke("stmp.examples.room.RoomEvents.NewMessage", input, notifyOptions) }
   static NewMessageToSet(input, conns, excludes) { const pm = new PayloadMap(input); for (const conn of conns) (!excludes || excludes.indexOf(conn) < 0) && conn.call("stmp.examples.room.RoomEvents.NewMessage", pm.get(conn), notifyOptions) }
   static NewMessageToAll(input, srv, filter) { return srv.broadcast("stmp.examples.room.RoomEvents.NewMessage", input, filter) }
  };


});
