// Code generated by protoc-gen-stmp. DO NOT EDIT.
// source: examples/room/room_proto/room.proto
import pb from "./room.pb";
import { PayloadMap, registerMethodAction, notifyOptions } from "stmp";

const stmp = Object.create(null);

export default stmp;

function initNamespace(root, ns, factory) {
    for (const item of ns.split(".")) {
        root = (root[item] = root[item] || Object.create(null))
    }
	factory(root)
}

initNamespace(stmp, "stmp.examples.room", (ns) => {


  registerMethodAction("stmp.examples.room.UserService.ListUser", "1001", pb.stmp.examples.room.ListUserInput, pb.stmp.examples.room.ListUserOutput);

  ns.UserServiceServer = class UserServiceServer {
    static register(srv, inst) {
      srv.register(inst, "stmp.examples.room.UserService.ListUser", inst.ListUser);
    }

    static unregister(srv, inst) {
      srv.unregister(inst, "stmp.examples.room.UserService.ListUser");
    }

    ListUser(ctx, input, output) { throw new Error("not implemented") }
  };
  
  ns.UserServiceBroadcaster = class UserServiceBroadcaster {
    static ListUser(input, conn, options) { return conn.invoke("stmp.examples.room.UserService.ListUser", input, options) }
    static ListUserForSet(input, conns) { const pm = new PayloadMap(input); for (const conn of conns) conn.call("stmp.examples.room.UserService.ListUser", pm.get(conn), notifyOptions) }
    static broadcastListUser(input, srv, filter) { return srv.broadcast("stmp.examples.room.UserService.ListUser", input, filter) }
    static ListUserMethod() { return "stmp.examples.room.UserService.ListUser" }
    static ListUserAction() { return "1001" }
  };
  
  ns.UserServiceClient = class UserServiceClient {
    constructor(conn) { this.conn = conn }
    ListUser(input, options) { return this.conn.invoke("stmp.examples.room.UserService.ListUser", input, options) }
  };

  registerMethodAction("stmp.examples.room.UserEvents.StatusUpdated", "1101", pb.stmp.examples.room.UserModel, pb.google.protobuf.Empty);

  ns.UserEventsServer = class UserEventsServer {
    static register(srv, inst) {
      srv.register(inst, "stmp.examples.room.UserEvents.StatusUpdated", inst.StatusUpdated);
    }

    static unregister(srv, inst) {
      srv.unregister(inst, "stmp.examples.room.UserEvents.StatusUpdated");
    }

    StatusUpdated(ctx, input, output) { throw new Error("not implemented") }
  };
  
  ns.UserEventsBroadcaster = class UserEventsBroadcaster {
    static StatusUpdated(input, conn, options) { return conn.invoke("stmp.examples.room.UserEvents.StatusUpdated", input, options) }
    static StatusUpdatedForSet(input, conns) { const pm = new PayloadMap(input); for (const conn of conns) conn.call("stmp.examples.room.UserEvents.StatusUpdated", pm.get(conn), notifyOptions) }
    static broadcastStatusUpdated(input, srv, filter) { return srv.broadcast("stmp.examples.room.UserEvents.StatusUpdated", input, filter) }
    static StatusUpdatedMethod() { return "stmp.examples.room.UserEvents.StatusUpdated" }
    static StatusUpdatedAction() { return "1101" }
  };
  
  ns.UserEventsClient = class UserEventsClient {
    constructor(conn) { this.conn = conn }
    StatusUpdated(input, options) { return this.conn.invoke("stmp.examples.room.UserEvents.StatusUpdated", input, options) }
  };

  registerMethodAction("stmp.examples.room.RoomService.CreateRoom", "1201", pb.stmp.examples.room.CreateRoomInput, pb.stmp.examples.room.RoomModel);
  registerMethodAction("stmp.examples.room.RoomService.ListRoom", "1202", pb.stmp.examples.room.ListRoomInput, pb.stmp.examples.room.ListRoomOutput);
  registerMethodAction("stmp.examples.room.RoomService.JoinRoom", "1203", pb.stmp.examples.room.JoinRoomInput, pb.stmp.examples.room.RoomModel);
  registerMethodAction("stmp.examples.room.RoomService.ExitRoom", "1204", pb.stmp.examples.room.ExitRoomInput, pb.google.protobuf.Empty);
  registerMethodAction("stmp.examples.room.RoomService.SendMessage", "1205", pb.stmp.examples.room.SendMessageInput, pb.google.protobuf.Empty);

  ns.RoomServiceServer = class RoomServiceServer {
    static register(srv, inst) {
      srv.register(inst, "stmp.examples.room.RoomService.CreateRoom", inst.CreateRoom);
      srv.register(inst, "stmp.examples.room.RoomService.ListRoom", inst.ListRoom);
      srv.register(inst, "stmp.examples.room.RoomService.JoinRoom", inst.JoinRoom);
      srv.register(inst, "stmp.examples.room.RoomService.ExitRoom", inst.ExitRoom);
      srv.register(inst, "stmp.examples.room.RoomService.SendMessage", inst.SendMessage);
    }

    static unregister(srv, inst) {
      srv.unregister(inst, "stmp.examples.room.RoomService.CreateRoom");
      srv.unregister(inst, "stmp.examples.room.RoomService.ListRoom");
      srv.unregister(inst, "stmp.examples.room.RoomService.JoinRoom");
      srv.unregister(inst, "stmp.examples.room.RoomService.ExitRoom");
      srv.unregister(inst, "stmp.examples.room.RoomService.SendMessage");
    }

    CreateRoom(ctx, input, output) { throw new Error("not implemented") }
    ListRoom(ctx, input, output) { throw new Error("not implemented") }
    JoinRoom(ctx, input, output) { throw new Error("not implemented") }
    ExitRoom(ctx, input, output) { throw new Error("not implemented") }
    SendMessage(ctx, input, output) { throw new Error("not implemented") }
  };
  
  ns.RoomServiceBroadcaster = class RoomServiceBroadcaster {
    static CreateRoom(input, conn, options) { return conn.invoke("stmp.examples.room.RoomService.CreateRoom", input, options) }
    static CreateRoomForSet(input, conns) { const pm = new PayloadMap(input); for (const conn of conns) conn.call("stmp.examples.room.RoomService.CreateRoom", pm.get(conn), notifyOptions) }
    static broadcastCreateRoom(input, srv, filter) { return srv.broadcast("stmp.examples.room.RoomService.CreateRoom", input, filter) }
    static CreateRoomMethod() { return "stmp.examples.room.RoomService.CreateRoom" }
    static CreateRoomAction() { return "1201" }
    static ListRoom(input, conn, options) { return conn.invoke("stmp.examples.room.RoomService.ListRoom", input, options) }
    static ListRoomForSet(input, conns) { const pm = new PayloadMap(input); for (const conn of conns) conn.call("stmp.examples.room.RoomService.ListRoom", pm.get(conn), notifyOptions) }
    static broadcastListRoom(input, srv, filter) { return srv.broadcast("stmp.examples.room.RoomService.ListRoom", input, filter) }
    static ListRoomMethod() { return "stmp.examples.room.RoomService.ListRoom" }
    static ListRoomAction() { return "1202" }
    static JoinRoom(input, conn, options) { return conn.invoke("stmp.examples.room.RoomService.JoinRoom", input, options) }
    static JoinRoomForSet(input, conns) { const pm = new PayloadMap(input); for (const conn of conns) conn.call("stmp.examples.room.RoomService.JoinRoom", pm.get(conn), notifyOptions) }
    static broadcastJoinRoom(input, srv, filter) { return srv.broadcast("stmp.examples.room.RoomService.JoinRoom", input, filter) }
    static JoinRoomMethod() { return "stmp.examples.room.RoomService.JoinRoom" }
    static JoinRoomAction() { return "1203" }
    static ExitRoom(input, conn, options) { return conn.invoke("stmp.examples.room.RoomService.ExitRoom", input, options) }
    static ExitRoomForSet(input, conns) { const pm = new PayloadMap(input); for (const conn of conns) conn.call("stmp.examples.room.RoomService.ExitRoom", pm.get(conn), notifyOptions) }
    static broadcastExitRoom(input, srv, filter) { return srv.broadcast("stmp.examples.room.RoomService.ExitRoom", input, filter) }
    static ExitRoomMethod() { return "stmp.examples.room.RoomService.ExitRoom" }
    static ExitRoomAction() { return "1204" }
    static SendMessage(input, conn, options) { return conn.invoke("stmp.examples.room.RoomService.SendMessage", input, options) }
    static SendMessageForSet(input, conns) { const pm = new PayloadMap(input); for (const conn of conns) conn.call("stmp.examples.room.RoomService.SendMessage", pm.get(conn), notifyOptions) }
    static broadcastSendMessage(input, srv, filter) { return srv.broadcast("stmp.examples.room.RoomService.SendMessage", input, filter) }
    static SendMessageMethod() { return "stmp.examples.room.RoomService.SendMessage" }
    static SendMessageAction() { return "1205" }
  };
  
  ns.RoomServiceClient = class RoomServiceClient {
    constructor(conn) { this.conn = conn }
    CreateRoom(input, options) { return this.conn.invoke("stmp.examples.room.RoomService.CreateRoom", input, options) }
    ListRoom(input, options) { return this.conn.invoke("stmp.examples.room.RoomService.ListRoom", input, options) }
    JoinRoom(input, options) { return this.conn.invoke("stmp.examples.room.RoomService.JoinRoom", input, options) }
    ExitRoom(input, options) { return this.conn.invoke("stmp.examples.room.RoomService.ExitRoom", input, options) }
    SendMessage(input, options) { return this.conn.invoke("stmp.examples.room.RoomService.SendMessage", input, options) }
  };

  registerMethodAction("stmp.examples.room.RoomEvents.UserEnter", "1301", pb.stmp.examples.room.UserEnterEvent, pb.google.protobuf.Empty);
  registerMethodAction("stmp.examples.room.RoomEvents.UserExit", "1302", pb.stmp.examples.room.UserExitEvent, pb.google.protobuf.Empty);
  registerMethodAction("stmp.examples.room.RoomEvents.NewMessage", "1303", pb.stmp.examples.room.ChatMessageModel, pb.google.protobuf.Empty);

  ns.RoomEventsServer = class RoomEventsServer {
    static register(srv, inst) {
      srv.register(inst, "stmp.examples.room.RoomEvents.UserEnter", inst.UserEnter);
      srv.register(inst, "stmp.examples.room.RoomEvents.UserExit", inst.UserExit);
      srv.register(inst, "stmp.examples.room.RoomEvents.NewMessage", inst.NewMessage);
    }

    static unregister(srv, inst) {
      srv.unregister(inst, "stmp.examples.room.RoomEvents.UserEnter");
      srv.unregister(inst, "stmp.examples.room.RoomEvents.UserExit");
      srv.unregister(inst, "stmp.examples.room.RoomEvents.NewMessage");
    }

    UserEnter(ctx, input, output) { throw new Error("not implemented") }
    UserExit(ctx, input, output) { throw new Error("not implemented") }
    NewMessage(ctx, input, output) { throw new Error("not implemented") }
  };
  
  ns.RoomEventsBroadcaster = class RoomEventsBroadcaster {
    static UserEnter(input, conn, options) { return conn.invoke("stmp.examples.room.RoomEvents.UserEnter", input, options) }
    static UserEnterForSet(input, conns) { const pm = new PayloadMap(input); for (const conn of conns) conn.call("stmp.examples.room.RoomEvents.UserEnter", pm.get(conn), notifyOptions) }
    static broadcastUserEnter(input, srv, filter) { return srv.broadcast("stmp.examples.room.RoomEvents.UserEnter", input, filter) }
    static UserEnterMethod() { return "stmp.examples.room.RoomEvents.UserEnter" }
    static UserEnterAction() { return "1301" }
    static UserExit(input, conn, options) { return conn.invoke("stmp.examples.room.RoomEvents.UserExit", input, options) }
    static UserExitForSet(input, conns) { const pm = new PayloadMap(input); for (const conn of conns) conn.call("stmp.examples.room.RoomEvents.UserExit", pm.get(conn), notifyOptions) }
    static broadcastUserExit(input, srv, filter) { return srv.broadcast("stmp.examples.room.RoomEvents.UserExit", input, filter) }
    static UserExitMethod() { return "stmp.examples.room.RoomEvents.UserExit" }
    static UserExitAction() { return "1302" }
    static NewMessage(input, conn, options) { return conn.invoke("stmp.examples.room.RoomEvents.NewMessage", input, options) }
    static NewMessageForSet(input, conns) { const pm = new PayloadMap(input); for (const conn of conns) conn.call("stmp.examples.room.RoomEvents.NewMessage", pm.get(conn), notifyOptions) }
    static broadcastNewMessage(input, srv, filter) { return srv.broadcast("stmp.examples.room.RoomEvents.NewMessage", input, filter) }
    static NewMessageMethod() { return "stmp.examples.room.RoomEvents.NewMessage" }
    static NewMessageAction() { return "1303" }
  };
  
  ns.RoomEventsClient = class RoomEventsClient {
    constructor(conn) { this.conn = conn }
    UserEnter(input, options) { return this.conn.invoke("stmp.examples.room.RoomEvents.UserEnter", input, options) }
    UserExit(input, options) { return this.conn.invoke("stmp.examples.room.RoomEvents.UserExit", input, options) }
    NewMessage(input, options) { return this.conn.invoke("stmp.examples.room.RoomEvents.NewMessage", input, options) }
  };
});
